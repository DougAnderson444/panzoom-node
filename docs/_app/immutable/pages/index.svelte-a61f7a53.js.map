{"version":3,"file":"index.svelte-a61f7a53.js","sources":["../../../../../../node_modules/@douganderson444/pointer-tracker/dist/PointerTracker.mjs","../../../../../../src/lib/pinchZoom.ts","../../../../../../src/lib/pzoom.ts","../../../../../../src/lib/_components/Spot.svelte","../../../../../../src/routes/index.svelte"],"sourcesContent":["class Pointer {\r\n    constructor(nativePointer) {\r\n        /** Unique ID for this pointer */\r\n        this.id = -1;\r\n        this.nativePointer = nativePointer;\r\n        this.pageX = nativePointer.pageX;\r\n        this.pageY = nativePointer.pageY;\r\n        this.clientX = nativePointer.clientX;\r\n        this.clientY = nativePointer.clientY;\r\n        if (self.Touch && nativePointer instanceof Touch) {\r\n            this.id = nativePointer.identifier;\r\n        }\r\n        else if (isPointerEvent(nativePointer)) {\r\n            // is PointerEvent\r\n            this.id = nativePointer.pointerId;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an expanded set of Pointers for high-resolution inputs.\r\n     */\r\n    getCoalesced() {\r\n        if ('getCoalescedEvents' in this.nativePointer) {\r\n            const events = this.nativePointer\r\n                .getCoalescedEvents()\r\n                .map((p) => new Pointer(p));\r\n            // Firefox sometimes returns an empty list here. I'm not sure it's doing the right thing.\r\n            // https://github.com/w3c/pointerevents/issues/409\r\n            if (events.length > 0)\r\n                return events;\r\n            // Otherwise, Firefox falls throughâ€¦\r\n        }\r\n        return [this];\r\n    }\r\n}\r\nconst isPointerEvent = (event) => 'pointerId' in event;\r\nconst isTouchEvent = (event) => 'changedTouches' in event;\r\nconst noop = () => { };\r\n/**\r\n * Track pointers across a particular element\r\n */\r\nclass PointerTracker {\r\n    /**\r\n     * Track pointers across a particular element\r\n     *\r\n     * @param element Element to monitor.\r\n     * @param options\r\n     */\r\n    constructor(_element, { start = () => true, move = noop, end = noop, rawUpdates = false, avoidPointerEvents = false, eventListenerOptions = { capture: false, passive: false, once: false }, } = {}) {\r\n        this._element = _element;\r\n        /**\r\n         * State of the tracked pointers when they were pressed/touched.\r\n         */\r\n        this.startPointers = [];\r\n        /**\r\n         * Latest state of the tracked pointers. Contains the same number of pointers, and in the same\r\n         * order as this.startPointers.\r\n         */\r\n        this.currentPointers = [];\r\n        /**\r\n         * Firefox has a bug where touch-based pointer events have a `buttons` of 0, when this shouldn't\r\n         * happen. https://bugzilla.mozilla.org/show_bug.cgi?id=1729440\r\n         *\r\n         * Usually we treat `buttons === 0` as no-longer-pressed. This set allows us to exclude these\r\n         * buggy Firefox events.\r\n         */\r\n        this._excludeFromButtonsCheck = new Set();\r\n        /**\r\n         * Listener for mouse/pointer starts.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerStart = (event) => {\r\n            if (isPointerEvent(event) && event.buttons === 0) {\r\n                // This is the buggy Firefox case. See _excludeFromButtonsCheck.\r\n                this._excludeFromButtonsCheck.add(event.pointerId);\r\n            }\r\n            else if (!(event.buttons & 1 /* LeftMouseOrTouchOrPenDown */)) {\r\n                return;\r\n            }\r\n            const pointer = new Pointer(event);\r\n            // If we're already tracking this pointer, ignore this event.\r\n            // This happens with mouse events when multiple buttons are pressed.\r\n            if (this.currentPointers.some((p) => p.id === pointer.id))\r\n                return;\r\n            if (!this._triggerPointerStart(pointer, event))\r\n                return;\r\n            // Add listeners for additional events.\r\n            // The listeners may already exist, but no harm in adding them again.\r\n            if (isPointerEvent(event)) {\r\n                const capturingElement = event.target && 'setPointerCapture' in event.target\r\n                    ? event.target\r\n                    : this._element;\r\n                capturingElement.setPointerCapture(event.pointerId);\r\n                this._element.addEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move, this._eventListenerOptions);\r\n                this._element.addEventListener('pointerup', this._pointerEnd, this._eventListenerOptions);\r\n                this._element.addEventListener('pointercancel', this._pointerEnd, this._eventListenerOptions);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.addEventListener('mousemove', this._move);\r\n                window.addEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchstart.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchStart = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerStart(new Pointer(touch), event);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for pointer/mouse/touch move events.\r\n         */\r\n        this._move = (event) => {\r\n            if (!isTouchEvent(event) &&\r\n                (!isPointerEvent(event) ||\r\n                    !this._excludeFromButtonsCheck.has(event.pointerId)) &&\r\n                event.buttons === 0 /* None */) {\r\n                // This happens in a number of buggy cases where the browser failed to deliver a pointerup\r\n                // or pointercancel. If we see the pointer moving without any buttons down, synthesize an end.\r\n                // https://github.com/w3c/pointerevents/issues/407\r\n                // https://github.com/w3c/pointerevents/issues/408\r\n                this._pointerEnd(event);\r\n                return;\r\n            }\r\n            const previousPointers = this.currentPointers.slice();\r\n            const changedPointers = isTouchEvent(event)\r\n                ? Array.from(event.changedTouches).map((t) => new Pointer(t))\r\n                : [new Pointer(event)];\r\n            const trackedChangedPointers = [];\r\n            for (const pointer of changedPointers) {\r\n                const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n                if (index === -1)\r\n                    continue; // Not a pointer we're tracking\r\n                trackedChangedPointers.push(pointer);\r\n                this.currentPointers[index] = pointer;\r\n            }\r\n            if (trackedChangedPointers.length === 0)\r\n                return;\r\n            this._moveCallback(previousPointers, trackedChangedPointers, event);\r\n        };\r\n        /**\r\n         * Call the end callback for this pointer.\r\n         *\r\n         * @param pointer Pointer\r\n         * @param event Related event\r\n         */\r\n        this._triggerPointerEnd = (pointer, event) => {\r\n            // Main button still down?\r\n            // With mouse events, you get a mouseup per mouse button, so the left button might still be down.\r\n            if (!isTouchEvent(event) &&\r\n                event.buttons & 1 /* LeftMouseOrTouchOrPenDown */) {\r\n                return false;\r\n            }\r\n            const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n            // Not a pointer we're interested in?\r\n            if (index === -1)\r\n                return false;\r\n            this.currentPointers.splice(index, 1);\r\n            this.startPointers.splice(index, 1);\r\n            this._excludeFromButtonsCheck.delete(pointer.id);\r\n            // The event.type might be a 'move' event due to workarounds for weird mouse behaviour.\r\n            // See _move for details.\r\n            const cancelled = !(event.type === 'mouseup' ||\r\n                event.type === 'touchend' ||\r\n                event.type === 'pointerup');\r\n            this._endCallback(pointer, event, cancelled);\r\n            return true;\r\n        };\r\n        /**\r\n         * Listener for mouse/pointer ends.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerEnd = (event) => {\r\n            if (!this._triggerPointerEnd(new Pointer(event), event))\r\n                return;\r\n            if (isPointerEvent(event)) {\r\n                if (this.currentPointers.length)\r\n                    return;\r\n                this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.removeEventListener('pointerup', this._pointerEnd);\r\n                this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.removeEventListener('mousemove', this._move);\r\n                window.removeEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchend.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchEnd = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerEnd(new Pointer(touch), event);\r\n            }\r\n        };\r\n        this._startCallback = start;\r\n        this._moveCallback = move;\r\n        this._endCallback = end;\r\n        this._rawUpdates = rawUpdates && 'onpointerrawupdate' in window;\r\n        this._eventListenerOptions = eventListenerOptions;\r\n        // Add listeners\r\n        if (self.PointerEvent && !avoidPointerEvents) {\r\n            this._element.addEventListener('pointerdown', this._pointerStart, this._eventListenerOptions);\r\n        }\r\n        else {\r\n            this._element.addEventListener('mousedown', this._pointerStart, this._eventListenerOptions);\r\n            this._element.addEventListener('touchstart', this._touchStart, this._eventListenerOptions);\r\n            this._element.addEventListener('touchmove', this._move, this._eventListenerOptions);\r\n            this._element.addEventListener('touchend', this._touchEnd, this._eventListenerOptions);\r\n            this._element.addEventListener('touchcancel', this._touchEnd, this._eventListenerOptions);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stop() {\r\n        this._element.removeEventListener('pointerdown', this._pointerStart);\r\n        this._element.removeEventListener('mousedown', this._pointerStart);\r\n        this._element.removeEventListener('touchstart', this._touchStart);\r\n        this._element.removeEventListener('touchmove', this._move);\r\n        this._element.removeEventListener('touchend', this._touchEnd);\r\n        this._element.removeEventListener('touchcancel', this._touchEnd);\r\n        this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n        this._element.removeEventListener('pointerup', this._pointerEnd);\r\n        this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n        window.removeEventListener('mousemove', this._move);\r\n        window.removeEventListener('mouseup', this._pointerEnd);\r\n    }\r\n    /**\r\n     * Call the start callback for this pointer, and track it if the user wants.\r\n     *\r\n     * @param pointer Pointer\r\n     * @param event Related event\r\n     * @returns Whether the pointer is being tracked.\r\n     */\r\n    _triggerPointerStart(pointer, event) {\r\n        if (!this._startCallback(pointer, event))\r\n            return false;\r\n        this.currentPointers.push(pointer);\r\n        this.startPointers.push(pointer);\r\n        return true;\r\n    }\r\n}\n\nexport { PointerTracker as default };\n","// inspired by https://github.com/GoogleChromeLabs/pinch-zoom/blob/master/lib/pinch-zoom.ts\r\n\r\nimport PointerTracker from '@douganderson444/pointer-tracker';\r\nimport type { Pointer } from '@douganderson444/pointer-tracker'; // separate type out to own line\r\nimport './styles.css';\r\n\r\ninterface Point {\r\n\tclientX: number;\r\n\tclientY: number;\r\n}\r\n\r\ninterface ChangeOptions {\r\n\t/**\r\n\t * Fire a 'change' event if values are different to current values\r\n\t */\r\n\tallowChangeEvent?: boolean;\r\n}\r\n\r\ninterface ApplyChangeOpts extends ChangeOptions {\r\n\tpanX?: number;\r\n\tpanY?: number;\r\n\tscaleDiff?: number;\r\n\toriginX?: number;\r\n\toriginY?: number;\r\n}\r\n\r\ninterface SetTransformOpts extends ChangeOptions {\r\n\tscale?: number;\r\n\tx?: number;\r\n\ty?: number;\r\n}\r\n\r\ntype ScaleRelativeToValues = 'container' | 'content';\r\n\r\nconst minScaleAttr = 'min-scale';\r\n\r\nexport interface ScaleToOpts extends ChangeOptions {\r\n\t/** Transform origin. Can be a number, or string percent, eg \"50%\" */\r\n\toriginX?: number | string;\r\n\t/** Transform origin. Can be a number, or string percent, eg \"50%\" */\r\n\toriginY?: number | string;\r\n\t/** Should the transform origin be relative to the container, or content? */\r\n\trelativeTo?: ScaleRelativeToValues;\r\n}\r\n\r\nfunction getDistance(a: Point, b?: Point): number {\r\n\tif (!b) return 0;\r\n\treturn Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);\r\n}\r\n\r\nfunction getMidpoint(a: Point, b?: Point): Point {\r\n\tif (!b) return a;\r\n\r\n\treturn {\r\n\t\tclientX: (a.clientX + b.clientX) / 2,\r\n\t\tclientY: (a.clientY + b.clientY) / 2\r\n\t};\r\n}\r\n\r\nfunction getAbsoluteValue(value: string | number, max: number): number {\r\n\tif (typeof value === 'number') return value;\r\n\r\n\tif (value.trimRight().endsWith('%')) {\r\n\t\treturn (max * parseFloat(value)) / 100;\r\n\t}\r\n\treturn parseFloat(value);\r\n}\r\n\r\nfunction createMatrix(): DOMMatrix {\r\n\t// initialize a new 16 element 3D array matrix\r\n\treturn new DOMMatrix([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n}\r\n\r\nfunction createPoint(): DOMPoint {\r\n\treturn new DOMPoint();\r\n}\r\n\r\nconst MIN_SCALE = 0.01;\r\n\r\nexport default class PinchZoom {\r\n\t// The element that we'll transform.\r\n\tprivate _node: HTMLElement;\r\n\t// Ideally this would be shadow DOM, but we don't have the browser\r\n\t// support yet.\r\n\tprivate _parentEl?: HTMLElement;\r\n\t// Current transform.\r\n\tprivate _transform: DOMMatrix = createMatrix();\r\n\r\n\tprivate _pointerTracker: PointerTracker;\r\n\r\n\tprivate _handle: HTMLElement | null = null;\r\n\r\n\tstatic get observedAttributes() {\r\n\t\treturn [minScaleAttr];\r\n\t}\r\n\r\n\t/**\r\n\t * handle - an optional handle element to grab by\r\n\t */\r\n\tconstructor(\r\n\t\tnode: HTMLElement,\r\n\t\t{ panAnywhere, handle }: { handle?: HTMLElement | null; panAnywhere?: boolean } = {}\r\n\t) {\r\n\t\tthis._node = node;\r\n\t\tthis._parentEl = this._node.parentElement || document.body;\r\n\t\tthis._handle = handle;\r\n\r\n\t\t// Watch for children changes.\r\n\t\t// Note this won't fire for initial contents,\r\n\t\t// so _stageElChange is also called in connectedCallback.\r\n\t\tnew MutationObserver(() => this._stageElChange()).observe(this._node, { childList: true });\r\n\r\n\t\t// Watch for pointers (nodes[i] as HTMLElement)\r\n\t\tthis._pointerTracker = new PointerTracker(this._parentEl, {\r\n\t\t\teventListenerOptions: {\r\n\t\t\t\tcapture: false // catch the event before it goes to child in the DOM tree ?\r\n\t\t\t},\r\n\t\t\tstart: (pointer, event) => {\r\n\t\t\t\t// ignore single pointers on input / editable elements\r\n\t\t\t\tif (\r\n\t\t\t\t\tthis._pointerTracker.currentPointers.length === 0 &&\r\n\t\t\t\t\t(event.target instanceof HTMLInputElement || event.target.isContentEditable)\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 2 || !this._parentEl)\r\n\t\t\t\t\t// We only want to track 2 pointers at most\r\n\t\t\t\t\t// there already exists 2 pointers, and now this would have been the 3rd pointer so let's stop here\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t// if a parent contains dataset data-no-pan, then don't pan\r\n\t\t\t\tif (event.target.closest('[data-no-pan]')) return false;\r\n\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 1) {\r\n\t\t\t\t\t// there already exists one pointer, and now this is the second pointer\r\n\t\t\t\t\t// then it's a pinch zoom and can be from anywhere, incl if the pointer is over a DOM tree child\r\n\t\t\t\t\t// events on this element are captured (see eventListenerOptions above) so stopping prop means they don't go down the DOM tree\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\tevent.stopPropagation(); // if it's a 2 touch move, we want exclusive rights over the pointer\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 0) {\r\n\t\t\t\t\t// if length == 0, then this is the first pointer tracked\r\n\t\t\t\t\t// it's for panning, but only on the parent or this node\r\n\t\t\t\t\t// so event.target has to be on this node or it's parent to pan everybody\r\n\r\n\t\t\t\t\t// track this single pointer in case a second one gets added\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\tevent.stopPropagation();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t// else, the pointer event must have happened on a child node, where pan doesn't apply\r\n\t\t\t\treturn false;\r\n\t\t\t},\r\n\t\t\tmove: (previousPointers, changedPointers, event) => {\r\n\t\t\t\t// tracking purposes only, no action\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 0) return;\r\n\r\n\t\t\t\t// If it's a single pointer in a child, ignore it, unless it's a handle\r\n\t\t\t\tif (\r\n\t\t\t\t\t!panAnywhere &&\r\n\t\t\t\t\tthis._pointerTracker.currentPointers.length === 1 &&\r\n\t\t\t\t\t!(event.target == this._parentEl || event.target == node)\r\n\t\t\t\t)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t// pan if single pointer on parent container or target node\r\n\t\t\t\t// zoom if double pointer anywhere\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t\tevent.stopPropagation(); // continue exclusive rights over the pointer from DOM tree\r\n\t\t\t\tthis._onPointerMove(previousPointers, this._pointerTracker.currentPointers);\r\n\t\t\t},\r\n\t\t\tend: (pointer, event, cancelled) => {}\r\n\t\t});\r\n\r\n\t\tthis._parentEl.addEventListener('wheel', (event) => this._onWheel(event));\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\tthis._pointerTracker.stop();\r\n\t}\r\n\r\n\tattributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n\t\tif (name === minScaleAttr) {\r\n\t\t\tif (this.scale < this.minScale) {\r\n\t\t\t\tthis.setTransform({ scale: this.minScale });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tget minScale(): number {\r\n\t\tconst attrValue = this._node.getAttribute(minScaleAttr);\r\n\t\tif (!attrValue) return MIN_SCALE;\r\n\r\n\t\tconst value = parseFloat(attrValue);\r\n\t\tif (Number.isFinite(value)) return Math.max(MIN_SCALE, value);\r\n\r\n\t\treturn MIN_SCALE;\r\n\t}\r\n\r\n\tset minScale(value: number) {\r\n\t\tthis._node.setAttribute(minScaleAttr, String(value));\r\n\t}\r\n\r\n\tconnectedCallback() {\r\n\t\tthis._stageElChange();\r\n\t}\r\n\r\n\tget x() {\r\n\t\treturn this._transform.e;\r\n\t}\r\n\r\n\tget y() {\r\n\t\treturn this._transform.f;\r\n\t}\r\n\r\n\tget scale() {\r\n\t\treturn this._transform.a;\r\n\t}\r\n\r\n\t/**\r\n\t * Change the scale, adjusting x/y by a given transform origin.\r\n\t */\r\n\tscaleTo(scale: number, opts: ScaleToOpts = {}) {\r\n\t\tlet { originX = 0, originY = 0 } = opts;\r\n\r\n\t\tconst { relativeTo = 'content', allowChangeEvent = false } = opts;\r\n\r\n\t\tconst relativeToEl = relativeTo === 'content' ? this._parentEl : this._node;\r\n\r\n\t\t// No content element? Fall back to just setting scale\r\n\t\tif (!relativeToEl || !this._parentEl) {\r\n\t\t\tthis.setTransform({ scale, allowChangeEvent });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst rect = relativeToEl.getBoundingClientRect();\r\n\t\toriginX = getAbsoluteValue(originX, rect.width);\r\n\t\toriginY = getAbsoluteValue(originY, rect.height);\r\n\r\n\t\tif (relativeTo === 'content') {\r\n\t\t\toriginX += this.x;\r\n\t\t\toriginY += this.y;\r\n\t\t} else {\r\n\t\t\tconst currentRect = this._parentEl.getBoundingClientRect();\r\n\t\t\toriginX -= currentRect.left;\r\n\t\t\toriginY -= currentRect.top;\r\n\t\t}\r\n\r\n\t\tthis._applyChange({\r\n\t\t\tallowChangeEvent,\r\n\t\t\toriginX,\r\n\t\t\toriginY,\r\n\t\t\tscaleDiff: scale / this.scale\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Update the stage with a given scale/x/y.\r\n\t */\r\n\tsetTransform(opts: SetTransformOpts = {}) {\r\n\t\tconst { scale = this.scale, allowChangeEvent = false } = opts;\r\n\r\n\t\tlet { x = this.x, y = this.y } = opts;\r\n\r\n\t\t// If we don't have an element to position, just set the value as given.\r\n\t\t// We'll check bounds later.\r\n\t\tif (!this._parentEl) {\r\n\t\t\tthis._updateTransform(scale, x, y, allowChangeEvent);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Get current layout\r\n\t\tconst thisBounds = this._node.getBoundingClientRect();\r\n\t\tconst parentElBounds = this._parentEl.getBoundingClientRect();\r\n\r\n\t\t// Not displayed. May be disconnected or display:none.\r\n\t\t// Just take the values, and we'll check bounds later.\r\n\t\tif (!thisBounds.width || !thisBounds.height) {\r\n\t\t\tthis._updateTransform(scale, x, y, allowChangeEvent);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Create points for _parentEl.\r\n\t\tlet topLeft = createPoint();\r\n\t\ttopLeft.x = parentElBounds.left - thisBounds.left;\r\n\t\ttopLeft.y = parentElBounds.top - thisBounds.top;\r\n\t\tlet bottomRight = createPoint();\r\n\t\tbottomRight.x = parentElBounds.width + topLeft.x;\r\n\t\tbottomRight.y = parentElBounds.height + topLeft.y;\r\n\r\n\t\t// Calculate the intended position of _parentEl.\r\n\t\tconst matrix = createMatrix()\r\n\t\t\t.translate(x, y)\r\n\t\t\t.scale(scale)\r\n\t\t\t// Undo current transform\r\n\t\t\t.multiply(this._transform.inverse());\r\n\r\n\t\ttopLeft = topLeft.matrixTransform(matrix);\r\n\t\tbottomRight = bottomRight.matrixTransform(matrix);\r\n\r\n\t\t// Ensure _parentEl can't move beyond out-of-bounds.\r\n\t\t// Correct for x\r\n\t\t// if (topLeft.x > thisBounds.width) {\r\n\t\t// \tx += thisBounds.width - topLeft.x;\r\n\t\t// } else if (bottomRight.x < 0) {\r\n\t\t// \tx += -bottomRight.x;\r\n\t\t// }\r\n\r\n\t\t// Correct for y\r\n\t\t// if (topLeft.y > thisBounds.height) {\r\n\t\t// \ty += thisBounds.height - topLeft.y;\r\n\t\t// } else if (bottomRight.y < 0) {\r\n\t\t// \ty += -bottomRight.y;\r\n\t\t// }\r\n\r\n\t\tthis._updateTransform(scale, x, y, allowChangeEvent);\r\n\t}\r\n\r\n\t/**\r\n\t * Update transform values without checking bounds. This is only called in setTransform.\r\n\t */\r\n\tprivate _updateTransform(scale: number, x: number, y: number, allowChangeEvent: boolean) {\r\n\t\t// Avoid scaling to zero\r\n\t\tif (scale < this.minScale) return;\r\n\r\n\t\t// Return if there's no change\r\n\t\tif (scale === this.scale && x === this.x && y === this.y) return;\r\n\r\n\t\tthis._transform.e = x;\r\n\t\tthis._transform.f = y;\r\n\t\tthis._transform.d = this._transform.a = scale;\r\n\r\n\t\t// this._node.style.setProperty('--x', this.x + 'px');\r\n\t\t// this._node.style.setProperty('--y', this.y + 'px');\r\n\t\t// this._node.style.setProperty('--scale', this.scale + '');\r\n\r\n\t\tthis._node.style.transform = `translate(${x}px,${y}px) scale(${scale})`;\r\n\r\n\t\tif (allowChangeEvent) {\r\n\t\t\tconst event = new Event('change', { bubbles: true });\r\n\t\t\tthis._node.dispatchEvent(event);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Called when the direct children of this element change.\r\n\t * Until we have have shadow dom support across the board, we\r\n\t * require a single element to be the child of <pinch-zoom>, and\r\n\t * that's the element we pan/scale.\r\n\t */\r\n\tprivate _stageElChange() {\r\n\t\tthis._parentEl = this._node.parentElement || document.body;\r\n\r\n\t\t// Do a bounds check\r\n\t\tthis.setTransform({ allowChangeEvent: true });\r\n\t}\r\n\r\n\tprivate _onWheel(event: WheelEvent) {\r\n\t\tif (!this._parentEl) return;\r\n\t\t// if (this._parentEl !== event.target) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tconst currentRect = this._parentEl.getBoundingClientRect();\r\n\t\tlet { deltaY } = event;\r\n\t\tconst { ctrlKey, deltaMode } = event;\r\n\r\n\t\tif (deltaMode === 1) {\r\n\t\t\t// 1 is \"lines\", 0 is \"pixels\"\r\n\t\t\t// Firefox uses \"lines\" for some types of mouse\r\n\t\t\tdeltaY *= 15;\r\n\t\t}\r\n\r\n\t\t// ctrlKey is true when pinch-zooming on a trackpad.\r\n\t\tconst divisor = ctrlKey ? 200 : 600;\r\n\t\tconst scaleDiff = 1 - deltaY / divisor;\r\n\r\n\t\tthis._applyChange({\r\n\t\t\tscaleDiff,\r\n\t\t\toriginX: event.pageX - this._parentEl.offsetLeft - this._parentEl.clientWidth / 2,\r\n\t\t\toriginY: event.pageY - this._parentEl.offsetTop - this._parentEl.clientHeight / 2,\r\n\t\t\tallowChangeEvent: true\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _onPointerMove(previousPointers: Pointer[], currentPointers: Pointer[]) {\r\n\t\tif (!this._parentEl) return;\r\n\r\n\t\t// Combine next points with previous points\r\n\t\tconst currentRect = this._parentEl.getBoundingClientRect();\r\n\r\n\t\t// For calculating panning movement\r\n\t\tconst prevMidpoint = getMidpoint(previousPointers[0], previousPointers[1]);\r\n\t\tconst newMidpoint = getMidpoint(currentPointers[0], currentPointers[1]);\r\n\r\n\t\t// Midpoint within the element\r\n\t\tconst originX = prevMidpoint.clientX - currentRect.left - currentRect.width / 2;\r\n\t\tconst originY = prevMidpoint.clientY - currentRect.top - currentRect.height / 2;\r\n\r\n\t\t// Calculate the desired change in scale\r\n\t\tconst prevDistance = getDistance(previousPointers[0], previousPointers[1]);\r\n\t\tconst newDistance = getDistance(currentPointers[0], currentPointers[1]);\r\n\t\tconst scaleDiff = prevDistance ? newDistance / prevDistance : 1;\r\n\r\n\t\tthis._applyChange({\r\n\t\t\toriginX,\r\n\t\t\toriginY,\r\n\t\t\tscaleDiff,\r\n\t\t\tpanX: newMidpoint.clientX - prevMidpoint.clientX,\r\n\t\t\tpanY: newMidpoint.clientY - prevMidpoint.clientY,\r\n\t\t\tallowChangeEvent: true\r\n\t\t});\r\n\t}\r\n\r\n\t/** Transform the view & fire a change event */\r\n\tprivate _applyChange(opts: ApplyChangeOpts = {}) {\r\n\t\tconst {\r\n\t\t\tpanX = 0,\r\n\t\t\tpanY = 0,\r\n\t\t\toriginX = 0,\r\n\t\t\toriginY = 0,\r\n\t\t\tscaleDiff = 1,\r\n\t\t\tallowChangeEvent = false\r\n\t\t} = opts;\r\n\r\n\t\tconst matrix = createMatrix()\r\n\t\t\t// Translate according to panning.\r\n\t\t\t.translate(panX, panY)\r\n\t\t\t// Scale about the origin.\r\n\t\t\t.translate(originX, originY)\r\n\t\t\t// Apply current translate\r\n\t\t\t// .translate(this.x, this.y) // moved to line below vvv\r\n\t\t\t.scale(scaleDiff)\r\n\t\t\t.translate(-originX, -originY)\r\n\t\t\t// Apply current transform.\r\n\t\t\t.multiply(this._transform);\r\n\r\n\t\t// Convert the transform into basic translate & scale.\r\n\t\tthis.setTransform({\r\n\t\t\tallowChangeEvent,\r\n\t\t\tscale: matrix.a,\r\n\t\t\tx: matrix.e,\r\n\t\t\ty: matrix.f\r\n\t\t});\r\n\t}\r\n}\r\n","import pinchZoom from './pinchZoom';\r\n\r\nexport const pzoom = (node, params) => {\r\n\tconsole.log({ params });\r\n\tlet container = node.parentElement || document.body;\r\n\r\n\t// ensure touch and select action defaults are disable\r\n\tcontainer.style['touch-action'] = 'none';\r\n\tcontainer.style['user-select'] = 'none';\r\n\tcontainer.style['overflow'] = 'hidden';\r\n\tcontainer.style['position'] = 'relative';\r\n\r\n\tnode.style['touch-action'] = 'none';\r\n\tnode.style['user-select'] = 'none';\r\n\tnode.style['position'] = 'absolute';\r\n\tnode.style.width = '100%'; // makes the transfrom origin the same\r\n\tnode.style.height = '100%'; // otherwise the origin will be off, and I dont know yet how to correct for that\r\n\r\n\t// node.style['transform'] = 'translate(var(--x), var(--y)) scale(var(--scale))';\r\n\t// node.style['transform-origin'] = '0 0';\r\n\t// node.style['will-change'] = 'transform';\r\n\r\n\tlet zoomer = new pinchZoom(node as HTMLElement, {\r\n\t\thandle: params?.handle,\r\n\t\tpanAnywhere: params?.panAnywhere\r\n\t});\r\n\r\n\t// listen on node HTMLElement\r\n\tnode.addEventListener('home', handleScaleToHome);\r\n\tnode.addEventListener('scaleTo', handleScaleTo);\r\n\tnode.addEventListener('change', handleScaleChange);\r\n\tnode.addEventListener('setTransform', handleSetTransform);\r\n\r\n\tfunction handleScaleTo(val) {\r\n\t\tzoomer.scaleTo(val, { allowChangeEvent: true });\r\n\t}\r\n\r\n\tfunction handleScaleToHome(e) {\r\n\t\t// zoomer.scaleTo(1, { allowChangeEvent: true });\r\n\t\tzoomer.setTransform({ x: 0, y: 0, scale: 1, allowChangeEvent: true });\r\n\t}\r\n\r\n\tfunction handleSetTransform(e) {\r\n\t\tzoomer.setTransform({\r\n\t\t\tx: e.detail.x || 0,\r\n\t\t\ty: e.detail.y || 0,\r\n\t\t\tscale: e.detail.scale || 1,\r\n\t\t\tallowChangeEvent: true\r\n\t\t});\r\n\t}\r\n\r\n\tfunction handleScaleChange(e) {\r\n\t\tconst scale = e.target.style.transform.match(/scale\\((\\d+\\.?\\d*)\\)/)[1];\r\n\t\tnode.dispatchEvent(\r\n\t\t\tnew CustomEvent('scale', {\r\n\t\t\t\tdetail: { scale }\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\treturn {\r\n\t\tupdate(params) {\r\n\t\t\t// the value of `bar` has changed\r\n\t\t\tzoomer.destroy(); // old one\r\n\t\t\tzoomer = new pinchZoom(node as HTMLElement, {\r\n\t\t\t\thandle: params?.handle,\r\n\t\t\t\tpanAnywhere: params?.panAnywhere\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tdestroy() {\r\n\t\t\t// the node has been removed from the DOM\r\n\t\t\tzoomer.destroy();\r\n\t\t\t// remove scaleTo event listener\r\n\t\t\tnode.removeEventListener('home', handleScaleToHome);\r\n\t\t\t// remove scale event listener\r\n\t\t\tnode.removeEventListener('change', handleScaleChange);\r\n\t\t\t// remove scaleTo event listener\r\n\t\t\tnode.removeEventListener('scaleTo', handleScaleTo);\r\n\t\t\t// remove setTransform event listener\r\n\t\t\tnode.removeEventListener('setTransform', handleSetTransform);\r\n\t\t}\r\n\t};\r\n};\r\n","<script>\r\n\tlet range = 9;\r\n\texport let left = ((1 << range) * Math.random()) | 10;\r\n\texport let top = ((1 << range) * Math.random()) | 10;\r\n\r\n\tlet color = '#' + (((1 << 24) * Math.random()) | 4095).toString(16);\r\n</script>\r\n\r\n<div style=\"top: {top}px; left: {left}px; --color: {color};\">\r\n\t<!-- {left},{top} -->\r\n</div>\r\n\r\n<style>\r\n\tdiv {\r\n\t\t--size: 20px;\r\n\t\tposition: absolute;\r\n\t\tbackground-color: var(--color);\r\n\t\tborder: 1px solid #00000049;\r\n\t\twidth: var(--size);\r\n\t\theight: var(--size);\r\n\t}\r\n</style>\r\n","<script>\n\timport { panzoom } from '$lib/panzoom.js';\n\timport { pzoom } from '$lib/pzoom';\n\timport Spot from '$lib/_components/Spot.svelte';\n\timport RangeSlider from 'svelte-range-slider-pips';\n\n\tlet zoomable, container;\n\n\tlet handle;\n\tlet scale = 1;\n\tlet count = 10;\n\tlet min = count;\n\tlet values;\n\t$: if (scale) {\n\t\tvalues = [scale]; // match the directive scale level\n\t}\n\n\t$: if (zoomable?.style?.transform) console.log({ zoomable: zoomable.style.transform });\n\n\tfunction handleRangeChg(e) {\n\t\tzoomable.dispatchEvent(new CustomEvent('scaleTo', { detail: { scale: values[0] } }));\n\t}\n\n\tconst grid = Array.from({ length: count }, (_, i) =>\n\t\tArray.from({ length: count }, (_, j) => ({ id: i * count + j }))\n\t);\n\n\tfunction goHome(e) {\n\t\t// dispatch custom event to zoomable element\n\t\tzoomable.dispatchEvent(new CustomEvent('home'));\n\t}\n\tconst handleScaleChg = (e) => {\n\t\tscale = e.detail.scale;\n\t\tconsole.log('scale changed', scale);\n\t};\n</script>\n\n<div>\n\t<h1>Pan and Zoom</h1>\n\t<p>Try out the mouse wheel scroll in the red box below</p>\n\n\t<h2>Inside</h2>\n\t<p>Inside the red box should pan and zoom</p>\n</div>\n\n<div class=\"container\" bind:this={container}>\n\t<div class=\"menu\">\n\t\t<div>\n\t\t\t<button on:click={goHome}>Reset Zoom</button>\n\t\t\t<br />Zoom Level: {scale}\n\t\t\t<!-- {#if values?.length}\n\t\t\t\t<div data-no-pan>\n\t\t\t\t\t<RangeSlider\n\t\t\t\t\t\tpips\n\t\t\t\t\t\tmin={0.1}\n\t\t\t\t\t\tstep={0.1}\n\t\t\t\t\t\tmax={scale?.max || 20}\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbind:values\n\t\t\t\t\t\ton:change={handleRangeChg}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t{/if} -->\n\t\t</div>\n\t</div>\n\t<div\n\t\tclass=\"zoomable flexbox\"\n\t\tbind:this={zoomable}\n\t\tuse:pzoom={{ panAnywhere: true }}\n\t\ton:scale={handleScaleChg}\n\t>\n\t\t{#if container}\n\t\t\t<div class=\"grid\">\n\t\t\t\t{#each grid as col, x}\n\t\t\t\t\t<div class=\"col\">\n\t\t\t\t\t\t{#each col as square, y}\n\t\t\t\t\t\t\t<Spot\n\t\t\t\t\t\t\t\tleft={min + (x * container.offsetWidth) / count}\n\t\t\t\t\t\t\t\ttop={min + (y * container.offsetWidth) / count}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</div>\n\t\t\t\t{/each}\n\t\t\t</div>\n\t\t{/if}\n\t</div>\n</div>\n\n<h2>Using Handle (WIP)</h2>\n\n<div style=\"height:600px\">\n\t<div style=\"height:600px; width: 600px; border: 1px solid salmon\">\n\t\t<div\n\t\t\tstyle=\"box-shadow: 2px 2px 19px #e0e0e0;\n\t\t-o-box-shadow: 2px 2px 19px #e0e0e0;\n\t\t-webkit-box-shadow: 2px 2px 19px #e0e0e0;\n\t\t-moz-box-shadow: 2px 2px 19px #e0e0e0;\n\t\t-moz-border-radius: 8px;\n\t\tborder-radius: 8px;\n\t\tbackground-color: rgba(250, 128, 114, 0.418);\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tpadding: 1em;\n\t\tleft: 100px;\n\t\ttop: 10px;\"\n\t\t\tuse:pzoom={{ handle }}\n\t\t>\n\t\t\tDrag me by my handle:\n\t\t\t<span bind:this={handle}>Handle</span>\n\t\t</div>\n\t</div>\n</div>\n\n<style>\n\t.container {\n\t\tborder: 3px solid red;\n\t\theight: 600px;\n\t\twidth: 600px;\n\t\tmargin: 3em;\n\t\t/* overflow: hidden;  its set by the directive :) */\n\t\t/* touch-action: none;  its set by the directive :) */\n\t\t/* position: relative; its set by the directive :) */\n\t}\n\t.zoomable {\n\t\tborder: 4px dashed blue;\n\t\theight: 50%;\n\t\twidth: 50%;\n\t\t/* margin: 1em; */\n\t\t/* position: relative; its set by the directive :) */\n\t}\n\t.flexbox {\n\t\tdisplay: flex;\n\t\tflex-wrap: nowrap;\n\t\talign-content: stretch;\n\t\tjustify-content: space-evenly;\n\t\talign-items: stretch;\n\t}\n\t.flexitem {\n\t\tmargin: 1em;\n\t\tpadding: 1em;\n\t\tbackground-color: lightgray;\n\t}\n\t.item {\n\t\t/* \t\tflex: 1; */\n\t\tborder: 1px solid grey;\n\t\theight: 30px;\n\t\twidth: 50px;\n\t}\n\tul {\n\t\tpadding: 1em;\n\t}\n\n\t.menu {\n\t\tposition: absolute;\n\t\ttop: 10px;\n\t\tleft: 10px;\n\t\twidth: 400px;\n\t\tmargin: 0.1em;\n\t\tpadding: 2em;\n\t\tz-index: 10;\n\t\tbackground-color: rgba(133, 198, 255, 0.801);\n\t}\n</style>\n"],"names":["pinchZoom"],"mappings":"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"}