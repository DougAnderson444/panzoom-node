{"version":3,"file":"index.svelte-698267e4.js","sources":["../../../../../node_modules/pointer-tracker/dist/PointerTracker.mjs","../../../../../src/lib/pinchZoom.ts","../../../../../src/lib/pzoom.ts","../../../../../src/lib/_components/Spot.svelte","../../../../../node_modules/svelte/motion/index.mjs","../../../../../node_modules/svelte-range-slider-pips/src/RangePips.svelte","../../../../../node_modules/svelte-range-slider-pips/src/RangeSlider.svelte","../../../../../src/routes/index.svelte"],"sourcesContent":["class Pointer {\r\n    constructor(nativePointer) {\r\n        /** Unique ID for this pointer */\r\n        this.id = -1;\r\n        this.nativePointer = nativePointer;\r\n        this.pageX = nativePointer.pageX;\r\n        this.pageY = nativePointer.pageY;\r\n        this.clientX = nativePointer.clientX;\r\n        this.clientY = nativePointer.clientY;\r\n        if (self.Touch && nativePointer instanceof Touch) {\r\n            this.id = nativePointer.identifier;\r\n        }\r\n        else if (isPointerEvent(nativePointer)) {\r\n            // is PointerEvent\r\n            this.id = nativePointer.pointerId;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an expanded set of Pointers for high-resolution inputs.\r\n     */\r\n    getCoalesced() {\r\n        if ('getCoalescedEvents' in this.nativePointer) {\r\n            const events = this.nativePointer\r\n                .getCoalescedEvents()\r\n                .map((p) => new Pointer(p));\r\n            // Firefox sometimes returns an empty list here. I'm not sure it's doing the right thing.\r\n            // https://github.com/w3c/pointerevents/issues/409\r\n            if (events.length > 0)\r\n                return events;\r\n            // Otherwise, Firefox falls throughâ€¦\r\n        }\r\n        return [this];\r\n    }\r\n}\r\nconst isPointerEvent = (event) => 'pointerId' in event;\r\nconst isTouchEvent = (event) => 'changedTouches' in event;\r\nconst noop = () => { };\r\n/**\r\n * Track pointers across a particular element\r\n */\r\nclass PointerTracker {\r\n    /**\r\n     * Track pointers across a particular element\r\n     *\r\n     * @param element Element to monitor.\r\n     * @param options\r\n     */\r\n    constructor(_element, { start = () => true, move = noop, end = noop, rawUpdates = false, avoidPointerEvents = false, eventListenerOptions = { capture: false, passive: false, once: false }, } = {}) {\r\n        this._element = _element;\r\n        /**\r\n         * State of the tracked pointers when they were pressed/touched.\r\n         */\r\n        this.startPointers = [];\r\n        /**\r\n         * Latest state of the tracked pointers. Contains the same number of pointers, and in the same\r\n         * order as this.startPointers.\r\n         */\r\n        this.currentPointers = [];\r\n        /**\r\n         * Firefox has a bug where touch-based pointer events have a `buttons` of 0, when this shouldn't\r\n         * happen. https://bugzilla.mozilla.org/show_bug.cgi?id=1729440\r\n         *\r\n         * Usually we treat `buttons === 0` as no-longer-pressed. This set allows us to exclude these\r\n         * buggy Firefox events.\r\n         */\r\n        this._excludeFromButtonsCheck = new Set();\r\n        /**\r\n         * Listener for mouse/pointer starts.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerStart = (event) => {\r\n            if (isPointerEvent(event) && event.buttons === 0) {\r\n                // This is the buggy Firefox case. See _excludeFromButtonsCheck.\r\n                this._excludeFromButtonsCheck.add(event.pointerId);\r\n            }\r\n            else if (!(event.buttons & 1 /* LeftMouseOrTouchOrPenDown */)) {\r\n                return;\r\n            }\r\n            const pointer = new Pointer(event);\r\n            // If we're already tracking this pointer, ignore this event.\r\n            // This happens with mouse events when multiple buttons are pressed.\r\n            if (this.currentPointers.some((p) => p.id === pointer.id))\r\n                return;\r\n            if (!this._triggerPointerStart(pointer, event))\r\n                return;\r\n            // Add listeners for additional events.\r\n            // The listeners may already exist, but no harm in adding them again.\r\n            if (isPointerEvent(event)) {\r\n                const capturingElement = event.target && 'setPointerCapture' in event.target\r\n                    ? event.target\r\n                    : this._element;\r\n                capturingElement.setPointerCapture(event.pointerId);\r\n                this._element.addEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move, this._eventListenerOptions);\r\n                this._element.addEventListener('pointerup', this._pointerEnd, this._eventListenerOptions);\r\n                this._element.addEventListener('pointercancel', this._pointerEnd, this._eventListenerOptions);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.addEventListener('mousemove', this._move);\r\n                window.addEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchstart.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchStart = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerStart(new Pointer(touch), event);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for pointer/mouse/touch move events.\r\n         */\r\n        this._move = (event) => {\r\n            if (!isTouchEvent(event) &&\r\n                (!isPointerEvent(event) ||\r\n                    !this._excludeFromButtonsCheck.has(event.pointerId)) &&\r\n                event.buttons === 0 /* None */) {\r\n                // This happens in a number of buggy cases where the browser failed to deliver a pointerup\r\n                // or pointercancel. If we see the pointer moving without any buttons down, synthesize an end.\r\n                // https://github.com/w3c/pointerevents/issues/407\r\n                // https://github.com/w3c/pointerevents/issues/408\r\n                this._pointerEnd(event);\r\n                return;\r\n            }\r\n            const previousPointers = this.currentPointers.slice();\r\n            const changedPointers = isTouchEvent(event)\r\n                ? Array.from(event.changedTouches).map((t) => new Pointer(t))\r\n                : [new Pointer(event)];\r\n            const trackedChangedPointers = [];\r\n            for (const pointer of changedPointers) {\r\n                const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n                if (index === -1)\r\n                    continue; // Not a pointer we're tracking\r\n                trackedChangedPointers.push(pointer);\r\n                this.currentPointers[index] = pointer;\r\n            }\r\n            if (trackedChangedPointers.length === 0)\r\n                return;\r\n            this._moveCallback(previousPointers, trackedChangedPointers, event);\r\n        };\r\n        /**\r\n         * Call the end callback for this pointer.\r\n         *\r\n         * @param pointer Pointer\r\n         * @param event Related event\r\n         */\r\n        this._triggerPointerEnd = (pointer, event) => {\r\n            // Main button still down?\r\n            // With mouse events, you get a mouseup per mouse button, so the left button might still be down.\r\n            if (!isTouchEvent(event) &&\r\n                event.buttons & 1 /* LeftMouseOrTouchOrPenDown */) {\r\n                return false;\r\n            }\r\n            const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n            // Not a pointer we're interested in?\r\n            if (index === -1)\r\n                return false;\r\n            this.currentPointers.splice(index, 1);\r\n            this.startPointers.splice(index, 1);\r\n            this._excludeFromButtonsCheck.delete(pointer.id);\r\n            // The event.type might be a 'move' event due to workarounds for weird mouse behaviour.\r\n            // See _move for details.\r\n            const cancelled = !(event.type === 'mouseup' ||\r\n                event.type === 'touchend' ||\r\n                event.type === 'pointerup');\r\n            this._endCallback(pointer, event, cancelled);\r\n            return true;\r\n        };\r\n        /**\r\n         * Listener for mouse/pointer ends.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerEnd = (event) => {\r\n            if (!this._triggerPointerEnd(new Pointer(event), event))\r\n                return;\r\n            if (isPointerEvent(event)) {\r\n                if (this.currentPointers.length)\r\n                    return;\r\n                this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.removeEventListener('pointerup', this._pointerEnd);\r\n                this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.removeEventListener('mousemove', this._move);\r\n                window.removeEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchend.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchEnd = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerEnd(new Pointer(touch), event);\r\n            }\r\n        };\r\n        this._startCallback = start;\r\n        this._moveCallback = move;\r\n        this._endCallback = end;\r\n        this._rawUpdates = rawUpdates && 'onpointerrawupdate' in window;\r\n        this._eventListenerOptions = eventListenerOptions;\r\n        // Add listeners\r\n        if (self.PointerEvent && !avoidPointerEvents) {\r\n            this._element.addEventListener('pointerdown', this._pointerStart, this._eventListenerOptions);\r\n        }\r\n        else {\r\n            this._element.addEventListener('mousedown', this._pointerStart, this._eventListenerOptions);\r\n            this._element.addEventListener('touchstart', this._touchStart, this._eventListenerOptions);\r\n            this._element.addEventListener('touchmove', this._move, this._eventListenerOptions);\r\n            this._element.addEventListener('touchend', this._touchEnd, this._eventListenerOptions);\r\n            this._element.addEventListener('touchcancel', this._touchEnd, this._eventListenerOptions);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stop() {\r\n        this._element.removeEventListener('pointerdown', this._pointerStart);\r\n        this._element.removeEventListener('mousedown', this._pointerStart);\r\n        this._element.removeEventListener('touchstart', this._touchStart);\r\n        this._element.removeEventListener('touchmove', this._move);\r\n        this._element.removeEventListener('touchend', this._touchEnd);\r\n        this._element.removeEventListener('touchcancel', this._touchEnd);\r\n        this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n        this._element.removeEventListener('pointerup', this._pointerEnd);\r\n        this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n        window.removeEventListener('mousemove', this._move);\r\n        window.removeEventListener('mouseup', this._pointerEnd);\r\n    }\r\n    /**\r\n     * Call the start callback for this pointer, and track it if the user wants.\r\n     *\r\n     * @param pointer Pointer\r\n     * @param event Related event\r\n     * @returns Whether the pointer is being tracked.\r\n     */\r\n    _triggerPointerStart(pointer, event) {\r\n        if (!this._startCallback(pointer, event))\r\n            return false;\r\n        this.currentPointers.push(pointer);\r\n        this.startPointers.push(pointer);\r\n        return true;\r\n    }\r\n}\n\nexport { PointerTracker as default };\n","// inspired by https://github.com/GoogleChromeLabs/pinch-zoom/blob/master/lib/pinch-zoom.ts\r\n\r\nimport PointerTracker from 'pointer-tracker';\r\nimport type { Pointer } from 'pointer-tracker'; // separate type out to own line\r\nimport './styles.css';\r\n\r\ninterface Point {\r\n\tclientX: number;\r\n\tclientY: number;\r\n}\r\n\r\ninterface ChangeOptions {\r\n\t/**\r\n\t * Fire a 'change' event if values are different to current values\r\n\t */\r\n\tallowChangeEvent?: boolean;\r\n}\r\n\r\ninterface ApplyChangeOpts extends ChangeOptions {\r\n\tpanX?: number;\r\n\tpanY?: number;\r\n\tscaleDiff?: number;\r\n\toriginX?: number;\r\n\toriginY?: number;\r\n}\r\n\r\ninterface SetTransformOpts extends ChangeOptions {\r\n\tscale?: number;\r\n\tx?: number;\r\n\ty?: number;\r\n}\r\n\r\ntype ScaleRelativeToValues = 'container' | 'content';\r\n\r\nconst minScaleAttr = 'min-scale';\r\n\r\nexport interface ScaleToOpts extends ChangeOptions {\r\n\t/** Transform origin. Can be a number, or string percent, eg \"50%\" */\r\n\toriginX?: number | string;\r\n\t/** Transform origin. Can be a number, or string percent, eg \"50%\" */\r\n\toriginY?: number | string;\r\n\t/** Should the transform origin be relative to the container, or content? */\r\n\trelativeTo?: ScaleRelativeToValues;\r\n}\r\n\r\nfunction getDistance(a: Point, b?: Point): number {\r\n\tif (!b) return 0;\r\n\treturn Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);\r\n}\r\n\r\nfunction getMidpoint(a: Point, b?: Point): Point {\r\n\tif (!b) return a;\r\n\r\n\treturn {\r\n\t\tclientX: (a.clientX + b.clientX) / 2,\r\n\t\tclientY: (a.clientY + b.clientY) / 2\r\n\t};\r\n}\r\n\r\nfunction getAbsoluteValue(value: string | number, max: number): number {\r\n\tif (typeof value === 'number') return value;\r\n\r\n\tif (value.trimRight().endsWith('%')) {\r\n\t\treturn (max * parseFloat(value)) / 100;\r\n\t}\r\n\treturn parseFloat(value);\r\n}\r\n\r\nfunction createMatrix(): DOMMatrix {\r\n\treturn new DOMMatrix();\r\n}\r\n\r\nfunction createPoint(): DOMPoint {\r\n\treturn new DOMPoint();\r\n}\r\n\r\nconst MIN_SCALE = 0.01;\r\n\r\nexport default class PinchZoom {\r\n\t// The element that we'll transform.\r\n\tprivate _node: HTMLElement;\r\n\t// Ideally this would be shadow DOM, but we don't have the browser\r\n\t// support yet.\r\n\tprivate _parentEl?: HTMLElement;\r\n\t// Current transform.\r\n\tprivate _transform: DOMMatrix = createMatrix();\r\n\r\n\tprivate _pointerTracker: PointerTracker;\r\n\r\n\tstatic get observedAttributes() {\r\n\t\treturn [minScaleAttr];\r\n\t}\r\n\r\n\tconstructor(node: HTMLElement) {\r\n\t\tthis._node = node;\r\n\t\tthis._parentEl = this._node.parentElement || document.body;\r\n\r\n\t\t// Watch for children changes.\r\n\t\t// Note this won't fire for initial contents,\r\n\t\t// so _stageElChange is also called in connectedCallback.\r\n\t\tnew MutationObserver(() => this._stageElChange()).observe(this._node, { childList: true });\r\n\r\n\t\t// Watch for pointers (nodes[i] as HTMLElement)\r\n\t\tthis._pointerTracker = new PointerTracker(this._parentEl, {\r\n\t\t\teventListenerOptions: { capture: true }, // catch the event before it goes to child in the DOM tree\r\n\t\t\tstart: (pointer, event) => {\r\n\t\t\t\t// We only want to track 2 pointers at most\r\n\t\t\t\t// there already exists 2 pointers, and now this would have been the 3rd pointer so let's stop here\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 2 || !this._parentEl) return false;\r\n\r\n\t\t\t\tevent.preventDefault();\r\n\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 1) {\r\n\t\t\t\t\t// there already exists one pointer, and now this is the second pointer\r\n\t\t\t\t\t// then it's a pinch zoom and can be from anywhere, incl if the pointer is over a DOM tree child\r\n\t\t\t\t\t// events on this element are captured (see eventListenerOptions above) so stopping prop means they don't go down the DOM tree\r\n\t\t\t\t\tevent.stopPropagation(); // if it's a 2 touch move, we want exclusive rights over the pointer\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 0) {\r\n\t\t\t\t\t// if length == 0, then this is the first pointer tracked\r\n\t\t\t\t\t// it's for panning, but only on the parent or this node\r\n\t\t\t\t\t// so event.target has to be on this node or it's parent to pan everybody\r\n\r\n\t\t\t\t\t// track this single pointer in case a second one gets added\r\n\t\t\t\t\t// but don't block it's use by children, yet\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t// else, the pointer event must have happened on a child node, where pan doesn't apply\r\n\t\t\t},\r\n\t\t\tmove: (previousPointers, changedPointers, event) => {\r\n\t\t\t\t// console.log(`PanZoom MOVE currentPointers: ${this._pointerTracker.currentPointers.length}`);\r\n\r\n\t\t\t\t// tracking purposes only, no action\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 0) return\r\n\r\n\t\t\t\t// If it's a single pointer in a child, ignore it\r\n\t\t\t\tif (this._pointerTracker.currentPointers.length === 1 && !(event.target == this._parentEl || event.target == node)) return\r\n\r\n\t\t\t\t// pan if single pointer on parent container or target node\r\n\t\t\t\t// zoom if double pointer anywhere\r\n\t\t\t\tevent.stopPropagation(); // continue exclusive rights over the pointer from DOM tree\r\n\t\t\t\tthis._onPointerMove(previousPointers, this._pointerTracker.currentPointers);\r\n\t\t\t},\r\n\t\t\tend: (pointer, event, cancelled) => {\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis._parentEl.addEventListener('wheel', (event) => this._onWheel(event));\r\n\t}\r\n\r\n\tattributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n\t\tif (name === minScaleAttr) {\r\n\t\t\tif (this.scale < this.minScale) {\r\n\t\t\t\tthis.setTransform({ scale: this.minScale });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tget minScale(): number {\r\n\t\tconst attrValue = this._node.getAttribute(minScaleAttr);\r\n\t\tif (!attrValue) return MIN_SCALE;\r\n\r\n\t\tconst value = parseFloat(attrValue);\r\n\t\tif (Number.isFinite(value)) return Math.max(MIN_SCALE, value);\r\n\r\n\t\treturn MIN_SCALE;\r\n\t}\r\n\r\n\tset minScale(value: number) {\r\n\t\tthis._node.setAttribute(minScaleAttr, String(value));\r\n\t}\r\n\r\n\tconnectedCallback() {\r\n\t\tthis._stageElChange();\r\n\t}\r\n\r\n\tget x() {\r\n\t\treturn this._transform.e;\r\n\t}\r\n\r\n\tget y() {\r\n\t\treturn this._transform.f;\r\n\t}\r\n\r\n\tget scale() {\r\n\t\treturn this._transform.a;\r\n\t}\r\n\r\n\t/**\r\n\t * Change the scale, adjusting x/y by a given transform origin.\r\n\t */\r\n\tscaleTo(scale: number, opts: ScaleToOpts = {}) {\r\n\t\tlet { originX = 0, originY = 0 } = opts;\r\n\r\n\t\tconst { relativeTo = 'content', allowChangeEvent = false } = opts;\r\n\r\n\t\tconst relativeToEl = relativeTo === 'content' ? this._parentEl : this._node;\r\n\r\n\t\t// No content element? Fall back to just setting scale\r\n\t\tif (!relativeToEl || !this._parentEl) {\r\n\t\t\tthis.setTransform({ scale, allowChangeEvent });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst rect = relativeToEl.getBoundingClientRect();\r\n\t\toriginX = getAbsoluteValue(originX, rect.width);\r\n\t\toriginY = getAbsoluteValue(originY, rect.height);\r\n\r\n\t\tif (relativeTo === 'content') {\r\n\t\t\toriginX += this.x;\r\n\t\t\toriginY += this.y;\r\n\t\t} else {\r\n\t\t\tconst currentRect = this._parentEl.getBoundingClientRect();\r\n\t\t\toriginX -= currentRect.left;\r\n\t\t\toriginY -= currentRect.top;\r\n\t\t}\r\n\r\n\t\tthis._applyChange({\r\n\t\t\tallowChangeEvent,\r\n\t\t\toriginX,\r\n\t\t\toriginY,\r\n\t\t\tscaleDiff: scale / this.scale\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Update the stage with a given scale/x/y.\r\n\t */\r\n\tsetTransform(opts: SetTransformOpts = {}) {\r\n\t\tconst { scale = this.scale, allowChangeEvent = false } = opts;\r\n\r\n\t\tlet { x = this.x, y = this.y } = opts;\r\n\r\n\t\t// If we don't have an element to position, just set the value as given.\r\n\t\t// We'll check bounds later.\r\n\t\tif (!this._parentEl) {\r\n\t\t\tthis._updateTransform(scale, x, y, allowChangeEvent);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Get current layout\r\n\t\tconst thisBounds = this._node.getBoundingClientRect();\r\n\t\tconst parentElBounds = this._parentEl.getBoundingClientRect();\r\n\r\n\t\t// Not displayed. May be disconnected or display:none.\r\n\t\t// Just take the values, and we'll check bounds later.\r\n\t\tif (!thisBounds.width || !thisBounds.height) {\r\n\t\t\tthis._updateTransform(scale, x, y, allowChangeEvent);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Create points for _parentEl.\r\n\t\tlet topLeft = createPoint();\r\n\t\ttopLeft.x = parentElBounds.left - thisBounds.left;\r\n\t\ttopLeft.y = parentElBounds.top - thisBounds.top;\r\n\t\tlet bottomRight = createPoint();\r\n\t\tbottomRight.x = parentElBounds.width + topLeft.x;\r\n\t\tbottomRight.y = parentElBounds.height + topLeft.y;\r\n\r\n\t\t// Calculate the intended position of _parentEl.\r\n\t\tconst matrix = createMatrix()\r\n\t\t\t.translate(x, y)\r\n\t\t\t.scale(scale)\r\n\t\t\t// Undo current transform\r\n\t\t\t.multiply(this._transform.inverse());\r\n\r\n\t\ttopLeft = topLeft.matrixTransform(matrix);\r\n\t\tbottomRight = bottomRight.matrixTransform(matrix);\r\n\r\n\t\t// Ensure _parentEl can't move beyond out-of-bounds.\r\n\t\t// Correct for x\r\n\t\t// if (topLeft.x > thisBounds.width) {\r\n\t\t// \tx += thisBounds.width - topLeft.x;\r\n\t\t// } else if (bottomRight.x < 0) {\r\n\t\t// \tx += -bottomRight.x;\r\n\t\t// }\r\n\r\n\t\t// Correct for y\r\n\t\t// if (topLeft.y > thisBounds.height) {\r\n\t\t// \ty += thisBounds.height - topLeft.y;\r\n\t\t// } else if (bottomRight.y < 0) {\r\n\t\t// \ty += -bottomRight.y;\r\n\t\t// }\r\n\r\n\t\tthis._updateTransform(scale, x, y, allowChangeEvent);\r\n\t}\r\n\r\n\t/**\r\n\t * Update transform values without checking bounds. This is only called in setTransform.\r\n\t */\r\n\tprivate _updateTransform(scale: number, x: number, y: number, allowChangeEvent: boolean) {\r\n\t\t// Avoid scaling to zero\r\n\t\tif (scale < this.minScale) return;\r\n\r\n\t\t// Return if there's no change\r\n\t\tif (scale === this.scale && x === this.x && y === this.y) return;\r\n\r\n\t\tthis._transform.e = x;\r\n\t\tthis._transform.f = y;\r\n\t\tthis._transform.d = this._transform.a = scale;\r\n\r\n\t\t// this._node.style.setProperty('--x', this.x + 'px');\r\n\t\t// this._node.style.setProperty('--y', this.y + 'px');\r\n\t\t// this._node.style.setProperty('--scale', this.scale + '');\r\n\r\n\t\tthis._node.style.transform = `translate(${x}px,${y}px) scale(${scale})`;\r\n\r\n\t\tif (allowChangeEvent) {\r\n\t\t\tconst event = new Event('change', { bubbles: true });\r\n\t\t\tthis._node.dispatchEvent(event);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Called when the direct children of this element change.\r\n\t * Until we have have shadow dom support across the board, we\r\n\t * require a single element to be the child of <pinch-zoom>, and\r\n\t * that's the element we pan/scale.\r\n\t */\r\n\tprivate _stageElChange() {\r\n\t\tthis._parentEl = this._node.parentElement || document.body;\r\n\r\n\t\t// Do a bounds check\r\n\t\tthis.setTransform({ allowChangeEvent: true });\r\n\t}\r\n\r\n\tprivate _onWheel(event: WheelEvent) {\r\n\t\tif (!this._parentEl) return;\r\n\t\t// if (this._parentEl !== event.target) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tconst currentRect = this._parentEl.getBoundingClientRect();\r\n\t\tlet { deltaY } = event;\r\n\t\tconst { ctrlKey, deltaMode } = event;\r\n\r\n\t\tif (deltaMode === 1) {\r\n\t\t\t// 1 is \"lines\", 0 is \"pixels\"\r\n\t\t\t// Firefox uses \"lines\" for some types of mouse\r\n\t\t\tdeltaY *= 15;\r\n\t\t}\r\n\r\n\t\t// ctrlKey is true when pinch-zooming on a trackpad.\r\n\t\tconst divisor = ctrlKey ? 200 : 600;\r\n\t\tconst scaleDiff = 1 - deltaY / divisor;\r\n\r\n\t\tthis._applyChange({\r\n\t\t\tscaleDiff,\r\n\t\t\toriginX: event.pageX - this._parentEl.offsetLeft - this._parentEl.clientWidth / 2,\r\n\t\t\toriginY: event.pageY - this._parentEl.offsetTop - this._parentEl.clientHeight / 2,\r\n\t\t\tallowChangeEvent: true\r\n\t\t});\r\n\t}\r\n\r\n\tprivate _onPointerMove(previousPointers: Pointer[], currentPointers: Pointer[]) {\r\n\t\tif (!this._parentEl) return;\r\n\r\n\t\t// Combine next points with previous points\r\n\t\tconst currentRect = this._parentEl.getBoundingClientRect();\r\n\r\n\t\t// For calculating panning movement\r\n\t\tconst prevMidpoint = getMidpoint(previousPointers[0], previousPointers[1]);\r\n\t\tconst newMidpoint = getMidpoint(currentPointers[0], currentPointers[1]);\r\n\r\n\t\t// Midpoint within the element\r\n\t\tconst originX = prevMidpoint.clientX - currentRect.left - currentRect.width / 2;\r\n\t\tconst originY = prevMidpoint.clientY - currentRect.top - currentRect.height / 2;\r\n\r\n\t\t// Calculate the desired change in scale\r\n\t\tconst prevDistance = getDistance(previousPointers[0], previousPointers[1]);\r\n\t\tconst newDistance = getDistance(currentPointers[0], currentPointers[1]);\r\n\t\tconst scaleDiff = prevDistance ? newDistance / prevDistance : 1;\r\n\r\n\t\tthis._applyChange({\r\n\t\t\toriginX,\r\n\t\t\toriginY,\r\n\t\t\tscaleDiff,\r\n\t\t\tpanX: newMidpoint.clientX - prevMidpoint.clientX,\r\n\t\t\tpanY: newMidpoint.clientY - prevMidpoint.clientY,\r\n\t\t\tallowChangeEvent: true\r\n\t\t});\r\n\t}\r\n\r\n\t/** Transform the view & fire a change event */\r\n\tprivate _applyChange(opts: ApplyChangeOpts = {}) {\r\n\t\tconst {\r\n\t\t\tpanX = 0,\r\n\t\t\tpanY = 0,\r\n\t\t\toriginX = 0,\r\n\t\t\toriginY = 0,\r\n\t\t\tscaleDiff = 1,\r\n\t\t\tallowChangeEvent = false\r\n\t\t} = opts;\r\n\r\n\t\tconst matrix = createMatrix()\r\n\t\t\t// Translate according to panning.\r\n\t\t\t.translate(panX, panY)\r\n\t\t\t// Scale about the origin.\r\n\t\t\t.translate(originX, originY)\r\n\t\t\t// Apply current translate\r\n\t\t\t// .translate(this.x, this.y) // moved to line below vvv\r\n\t\t\t.scale(scaleDiff)\r\n\t\t\t.translate(-originX, -originY)\r\n\t\t\t// Apply current transform.\r\n\t\t\t.multiply(this._transform);\r\n\r\n\t\t// Convert the transform into basic translate & scale.\r\n\t\tthis.setTransform({\r\n\t\t\tallowChangeEvent,\r\n\t\t\tscale: matrix.a,\r\n\t\t\tx: matrix.e,\r\n\t\t\ty: matrix.f\r\n\t\t});\r\n\t}\r\n}\r\n","import pinchZoom from './pinchZoom';\r\n\r\nexport const pzoom = (node, params = {}) => {\r\n\tlet container = node.parentElement || document.body;\r\n\r\n\t// ensure touch and select action defaults are disable\r\n\tcontainer.style['touch-action'] = 'none';\r\n\tcontainer.style['user-select'] = 'none';\r\n\tcontainer.style['overflow'] = 'hidden';\r\n\tcontainer.style['position'] = 'relative';\r\n\r\n\tnode.style['touch-action'] = 'none';\r\n\tnode.style['user-select'] = 'none';\r\n\tnode.style['position'] = 'absolute';\r\n\r\n\t// node.style['transform'] = 'translate(var(--x), var(--y)) scale(var(--scale))';\r\n\t// node.style['transform-origin'] = '0 0';\r\n\t// node.style['will-change'] = 'transform';\r\n\r\n\tnew pinchZoom(node as HTMLElement);\r\n};\r\n","<script>\r\n\tlet range = 9;\r\n\texport let left = ((1 << range) * Math.random()) | 10;\r\n\texport let top = ((1 << range) * Math.random()) | 10;\r\n\r\n\tlet color = '#' + (((1 << 24) * Math.random()) | 4095).toString(16);\r\n</script>\r\n\r\n<div style=\"top: {top}px; left: {left}px; --color: {color};\">\r\n\t<!-- {left},{top} -->\r\n</div>\r\n\r\n<style>\r\n\tdiv {\r\n\t\t--size: 20px;\r\n\t\tposition: absolute;\r\n\t\tbackground-color: var(--color);\r\n\t\tborder: 1px solid #00000049;\r\n\t\twidth: var(--size);\r\n\t\theight: var(--size);\r\n\t}\r\n</style>\r\n","import { writable } from '../store/index.mjs';\nimport { now, loop, assign } from '../internal/index.mjs';\nimport { linear } from '../easing/index.mjs';\n\nfunction is_date(obj) {\n    return Object.prototype.toString.call(obj) === '[object Date]';\n}\n\nfunction tick_spring(ctx, last_value, current_value, target_value) {\n    if (typeof current_value === 'number' || is_date(current_value)) {\n        // @ts-ignore\n        const delta = target_value - current_value;\n        // @ts-ignore\n        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0\n        const spring = ctx.opts.stiffness * delta;\n        const damper = ctx.opts.damping * velocity;\n        const acceleration = (spring - damper) * ctx.inv_mass;\n        const d = (velocity + acceleration) * ctx.dt;\n        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {\n            return target_value; // settled\n        }\n        else {\n            ctx.settled = false; // signal loop to keep ticking\n            // @ts-ignore\n            return is_date(current_value) ?\n                new Date(current_value.getTime() + d) : current_value + d;\n        }\n    }\n    else if (Array.isArray(current_value)) {\n        // @ts-ignore\n        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));\n    }\n    else if (typeof current_value === 'object') {\n        const next_value = {};\n        for (const k in current_value) {\n            // @ts-ignore\n            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);\n        }\n        // @ts-ignore\n        return next_value;\n    }\n    else {\n        throw new Error(`Cannot spring ${typeof current_value} values`);\n    }\n}\nfunction spring(value, opts = {}) {\n    const store = writable(value);\n    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;\n    let last_time;\n    let task;\n    let current_token;\n    let last_value = value;\n    let target_value = value;\n    let inv_mass = 1;\n    let inv_mass_recovery_rate = 0;\n    let cancel_task = false;\n    function set(new_value, opts = {}) {\n        target_value = new_value;\n        const token = current_token = {};\n        if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {\n            cancel_task = true; // cancel any running animation\n            last_time = now();\n            last_value = new_value;\n            store.set(value = target_value);\n            return Promise.resolve();\n        }\n        else if (opts.soft) {\n            const rate = opts.soft === true ? .5 : +opts.soft;\n            inv_mass_recovery_rate = 1 / (rate * 60);\n            inv_mass = 0; // infinite mass, unaffected by spring forces\n        }\n        if (!task) {\n            last_time = now();\n            cancel_task = false;\n            task = loop(now => {\n                if (cancel_task) {\n                    cancel_task = false;\n                    task = null;\n                    return false;\n                }\n                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);\n                const ctx = {\n                    inv_mass,\n                    opts: spring,\n                    settled: true,\n                    dt: (now - last_time) * 60 / 1000\n                };\n                const next_value = tick_spring(ctx, last_value, value, target_value);\n                last_time = now;\n                last_value = value;\n                store.set(value = next_value);\n                if (ctx.settled) {\n                    task = null;\n                }\n                return !ctx.settled;\n            });\n        }\n        return new Promise(fulfil => {\n            task.promise.then(() => {\n                if (token === current_token)\n                    fulfil();\n            });\n        });\n    }\n    const spring = {\n        set,\n        update: (fn, opts) => set(fn(target_value, value), opts),\n        subscribe: store.subscribe,\n        stiffness,\n        damping,\n        precision\n    };\n    return spring;\n}\n\nfunction get_interpolator(a, b) {\n    if (a === b || a !== a)\n        return () => a;\n    const type = typeof a;\n    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {\n        throw new Error('Cannot interpolate values of different type');\n    }\n    if (Array.isArray(a)) {\n        const arr = b.map((bi, i) => {\n            return get_interpolator(a[i], bi);\n        });\n        return t => arr.map(fn => fn(t));\n    }\n    if (type === 'object') {\n        if (!a || !b)\n            throw new Error('Object cannot be null');\n        if (is_date(a) && is_date(b)) {\n            a = a.getTime();\n            b = b.getTime();\n            const delta = b - a;\n            return t => new Date(a + t * delta);\n        }\n        const keys = Object.keys(b);\n        const interpolators = {};\n        keys.forEach(key => {\n            interpolators[key] = get_interpolator(a[key], b[key]);\n        });\n        return t => {\n            const result = {};\n            keys.forEach(key => {\n                result[key] = interpolators[key](t);\n            });\n            return result;\n        };\n    }\n    if (type === 'number') {\n        const delta = b - a;\n        return t => a + t * delta;\n    }\n    throw new Error(`Cannot interpolate ${type} values`);\n}\nfunction tweened(value, defaults = {}) {\n    const store = writable(value);\n    let task;\n    let target_value = value;\n    function set(new_value, opts) {\n        if (value == null) {\n            store.set(value = new_value);\n            return Promise.resolve();\n        }\n        target_value = new_value;\n        let previous_task = task;\n        let started = false;\n        let { delay = 0, duration = 400, easing = linear, interpolate = get_interpolator } = assign(assign({}, defaults), opts);\n        if (duration === 0) {\n            if (previous_task) {\n                previous_task.abort();\n                previous_task = null;\n            }\n            store.set(value = target_value);\n            return Promise.resolve();\n        }\n        const start = now() + delay;\n        let fn;\n        task = loop(now => {\n            if (now < start)\n                return true;\n            if (!started) {\n                fn = interpolate(value, new_value);\n                if (typeof duration === 'function')\n                    duration = duration(value, new_value);\n                started = true;\n            }\n            if (previous_task) {\n                previous_task.abort();\n                previous_task = null;\n            }\n            const elapsed = now - start;\n            if (elapsed > duration) {\n                store.set(value = new_value);\n                return false;\n            }\n            // @ts-ignore\n            store.set(value = fn(easing(elapsed / duration)));\n            return true;\n        });\n        return task.promise;\n    }\n    return {\n        set,\n        update: (fn, opts) => set(fn(target_value, value), opts),\n        subscribe: store.subscribe\n    };\n}\n\nexport { spring, tweened };\n","<script>\n\n  // range slider props\n  export let range = false;\n  export let min = 0;\n  export let max = 100;\n  export let step = 1;\n  export let values = [(max + min) / 2];\n  export let vertical = false;\n  export let reversed = false;\n  export let hoverable = true;\n  export let disabled = false;\n\n  // range pips / values props\n  export let pipstep = undefined;\n  export let all = true;\n  export let first = undefined;\n  export let last = undefined;\n  export let rest = undefined;\n\n  // formatting props\n  export let prefix = \"\";\n  export let suffix = \"\";\n  export let formatter = (v,i) => v;\n\n  // stylistic props\n  export let focus = undefined;\n  export let orientationStart = undefined;\n\n  // methods\n  export let percentOf = undefined;\n  export let moveHandle = undefined;\n  export let fixFloat = undefined;\n\n  $: pipStep = pipstep || ((max - min) / step >= ( vertical ? 50 : 100 ) ? (max - min) / ( vertical ? 10 : 20 ) : 1);\n\n  $: pipCount = parseInt((max - min) / (step * pipStep), 10);\n\n  $: pipVal = function(val) {\n    return fixFloat( min + val * step * pipStep );\n  };\n\n  $: isSelected = function(val) {\n    return values.some(v => fixFloat(v) === fixFloat(val));\n  };\n\n  $: inRange = function(val) {\n    if (range === \"min\") {\n      return values[0] > val;\n    } else if (range === \"max\") {\n      return values[0] < val;\n    } else if (range) {\n      return values[0] < val && values[1] > val;\n    }\n  };\n\n  function labelClick(val) {\n    if ( !disabled ) {\n      moveHandle( undefined, val );\n    }\n  }\n</script>\n\n<style>\n  :global(.rangeSlider) {\n    --pip: var(--range-pip, lightslategray);\n    --pip-text: var(--range-pip-text, var(--pip));\n    --pip-active: var(--range-pip-active, darkslategrey);\n    --pip-active-text: var(--range-pip-active-text, var(--pip-active));\n    --pip-hover: var(--range-pip-hover, darkslategrey);\n    --pip-hover-text: var(--range-pip-hover-text, var(--pip-hover));\n    --pip-in-range: var(--range-pip-in-range, var(--pip-active));\n    --pip-in-range-text: var(--range-pip-in-range-text, var(--pip-active-text));\n  }\n  :global(.rangePips) {\n    position: absolute;\n    height: 1em;\n    left: 0;\n    right: 0;\n    bottom: -1em;\n  }\n  :global(.rangePips.vertical) {\n    height: auto;\n    width: 1em;\n    left: 100%;\n    right: auto;\n    top: 0;\n    bottom: 0;\n  }\n  :global(.rangePips .pip) {\n    height: 0.4em;\n    position: absolute;\n    top: 0.25em;\n    width: 1px;\n    white-space: nowrap;\n  }\n  :global(.rangePips.vertical .pip) {\n    height: 1px;\n    width: 0.4em;\n    left: 0.25em;\n    top: auto;\n    bottom: auto;\n  }\n  :global(.rangePips .pipVal) {\n    position: absolute;\n    top: 0.4em;\n    transform: translate(-50%, 25%);\n  }\n  :global(.rangePips.vertical .pipVal) {\n    position: absolute;\n    top: 0;\n    left: 0.4em;\n    transform: translate(25%, -50%);\n  }\n  :global(.rangePips .pip) {\n    transition: all 0.15s ease;\n  }\n  :global(.rangePips .pipVal) {\n    transition: all 0.15s ease, font-weight 0s linear;\n  }\n  :global(.rangePips .pip) {\n    color: lightslategray;\n    color: var(--pip-text);\n    background-color: lightslategray;\n    background-color: var(--pip);\n  }\n  :global(.rangePips .pip.selected) {\n    color: darkslategrey;\n    color: var(--pip-active-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-active);\n  }\n  :global(.rangePips.hoverable:not(.disabled) .pip:hover) {\n    color: darkslategrey;\n    color: var(--pip-hover-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-hover);\n  }\n  :global(.rangePips .pip.in-range) {\n    color: darkslategrey;\n    color: var(--pip-in-range-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-in-range);\n  }\n  :global(.rangePips .pip.selected) {\n    height: 0.75em;\n  }\n  :global(.rangePips.vertical .pip.selected) {\n    height: 1px;\n    width: 0.75em;\n  }\n  :global(.rangePips .pip.selected .pipVal) {\n    font-weight: bold;\n    top: 0.75em;\n  }\n  :global(.rangePips.vertical .pip.selected .pipVal) {\n    top: 0;\n    left: 0.75em;\n  }\n  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):hover) {\n    transition: none;\n  }\n  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):hover .pipVal) {\n    transition: none;\n    font-weight: bold;\n  }\n</style>\n\n<div \n  class=\"rangePips\" \n  class:disabled\n  class:hoverable \n  class:vertical \n  class:reversed \n  class:focus \n>\n  {#if ( all && first !== false ) || first }\n    <span\n      class=\"pip first\"\n      class:selected={isSelected(min)}\n      class:in-range={inRange(min)}\n      style=\"{orientationStart}: 0%;\"\n      on:click={labelClick(min)}\n      on:touchend|preventDefault={labelClick(min)}\n    >\n      {#if all === 'label' || first === 'label'}\n        <span class=\"pipVal\">\n          {#if prefix}<span class=\"pipVal-prefix\">{prefix}</span>{/if}{formatter(fixFloat(min),0,0)}{#if suffix}<span class=\"pipVal-suffix\">{suffix}</span>{/if}\n        </span>\n      {/if}\n    </span>\n  {/if}\n\n  {#if ( all && rest !== false ) || rest}\n    {#each Array(pipCount + 1) as _, i}\n      {#if pipVal(i) !== min && pipVal(i) !== max}\n        <span\n          class=\"pip\"\n          class:selected={isSelected(pipVal(i))}\n          class:in-range={inRange(pipVal(i))}\n          style=\"{orientationStart}: {percentOf(pipVal(i))}%;\"\n          on:click={labelClick(pipVal(i))}\n          on:touchend|preventDefault={labelClick(pipVal(i))}\n        >\n          {#if all === 'label' || rest === 'label'}\n            <span class=\"pipVal\">\n              {#if prefix}<span class=\"pipVal-prefix\">{prefix}</span>{/if}{formatter(pipVal(i),i,percentOf(pipVal(i)))}{#if suffix}<span class=\"pipVal-suffix\">{suffix}</span>{/if}\n            </span>\n          {/if}\n        </span>\n      {/if}\n    {/each}\n  {/if}\n\n  {#if ( all && last !== false ) || last}\n    <span\n      class=\"pip last\"\n      class:selected={isSelected(max)}\n      class:in-range={inRange(max)}\n      style=\"{orientationStart}: 100%;\"\n      on:click={labelClick(max)}\n      on:touchend|preventDefault={labelClick(max)}\n    >\n      {#if all === 'label' || last === 'label'}\n        <span class=\"pipVal\">\n          {#if prefix}<span class=\"pipVal-prefix\">{prefix}</span>{/if}{formatter(fixFloat(max),pipCount,100)}{#if suffix}<span class=\"pipVal-suffix\">{suffix}</span>{/if}\n        </span>\n      {/if}\n    </span>\n  {/if}\n  \n</div>\n","<script>\n  import { spring } from \"svelte/motion\";\n  import { createEventDispatcher } from \"svelte\";\n  import RangePips from \"./RangePips.svelte\";\n\n  // dom references\n  export let slider = undefined;\n\n  // range slider props\n  export let range = false;\n  export let pushy = false;\n  export let min = 0;\n  export let max = 100;\n  export let step = 1;\n  export let values = [(max + min) / 2];\n  export let vertical = false;\n  export let float = false;\n  export let reversed = false;\n  export let hoverable = true;\n  export let disabled = false;\n\n  // range pips / values props\n  export let pips = false;\n  export let pipstep = undefined;\n  export let all = undefined;\n  export let first = undefined;\n  export let last = undefined;\n  export let rest = undefined;\n\n  // formatting props\n  export let id = undefined;\n  export let prefix = \"\";\n  export let suffix = \"\";\n  export let formatter = (v,i,p) => v;\n  export let handleFormatter = formatter;\n\n  // stylistic props\n  export let precision = 2;\n  export let springValues = { stiffness: 0.15, damping: 0.4 };\n\n  // prepare dispatched events\n  const dispatch = createEventDispatcher();\n\n  // state management\n  let valueLength = 0;\n  let focus = false;\n  let handleActivated = false;\n  let handlePressed = false;\n  let keyboardActive = false;\n  let activeHandle = values.length - 1;\n  let startValue;\n  let previousValue;\n\n  // copy the initial values in to a spring function which\n  // will update every time the values array is modified\n\n  let springPositions;\n\n  const fixFloat = (v) => parseFloat(v.toFixed(precision));\n\n  $: {\n\n    // check that \"values\" is an array, or set it as array\n    // to prevent any errors in springs, or range trimming\n    if ( !Array.isArray( values ) ) {\n      values = [(max + min) / 2];\n      console.error( \"'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)\" );\n    }\n    // trim the range so it remains as a min/max (only 2 handles)\n    // and also align the handles to the steps\n    values = trimRange(values.map((v) => alignValueToStep(v)));\n\n    // check if the valueLength (length of values[]) has changed,\n    // because if so we need to re-seed the spring function with the\n    // new values array.\n    if ( valueLength !== values.length ) {\n      // set the initial spring values when the slider initialises,\n      // or when values array length has changed\n      springPositions = spring(values.map((v) => percentOf(v)), springValues );\n    } else {\n      // update the value of the spring function for animated handles\n      // whenever the values has updated\n      springPositions.set(values.map((v) => percentOf(v)));\n    }\n    // set the valueLength for the next check\n    valueLength = values.length;\n  };\n\n  /**\n   * take in a value, and then calculate that value's percentage\n   * of the overall range (min-max);\n   * @param {number} val the value we're getting percent for\n   * @return {number} the percentage value\n   **/\n  $: percentOf = function (val) {\n    let perc = ((val - min) / (max - min)) * 100;\n    if (isNaN(perc) || perc <= 0) {\n      return 0;\n    } else if (perc >= 100) {\n      return 100;\n    } else {\n      return fixFloat(perc);\n    }\n  };\n\n  /**\n   * clamp a value from the range so that it always\n   * falls within the min/max values\n   * @param {number} val the value to clamp\n   * @return {number} the value after it's been clamped\n   **/\n  $: clampValue = function (val) {\n    // return the min/max if outside of that range\n    return val <= min ? min : val >= max ? max : val;\n  };\n\n  /**\n   * align the value with the steps so that it\n   * always sits on the closest (above/below) step\n   * @param {number} val the value to align\n   * @return {number} the value after it's been aligned\n   **/\n  $: alignValueToStep = function (val) {\n    // sanity check for performance\n    if (val <= min) {\n      return fixFloat(min);\n    } else if (val >= max) {\n      return fixFloat(max);\n    }\n    // find the middle-point between steps\n    // and see if the value is closer to the\n    // next step, or previous step\n    let remainder = (val - min) % step;\n    let aligned = val - remainder;\n    if (Math.abs(remainder) * 2 >= step) {\n      aligned += remainder > 0 ? step : -step;\n    }\n    // make sure the value is within acceptable limits\n    aligned = clampValue(aligned);\n    // make sure the returned value is set to the precision desired\n    // this is also because javascript often returns weird floats\n    // when dealing with odd numbers and percentages\n    return fixFloat(aligned);\n  };\n\n  /**\n   * the orientation of the handles/pips based on the\n   * input values of vertical and reversed\n   **/\n  $: orientationStart = vertical ? reversed ? 'top' : 'bottom' : reversed ? 'right' : 'left';\n  $: orientationEnd = vertical ? reversed ? 'bottom' : 'top' : reversed ? 'left' : 'right';\n\n  /**\n   * helper func to get the index of an element in it's DOM container\n   * @param {object} el dom object reference we want the index of\n   * @returns {number} the index of the input element\n   **/\n  function index(el) {\n    if (!el) return -1;\n    var i = 0;\n    while ((el = el.previousElementSibling)) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * normalise a mouse or touch event to return the\n   * client (x/y) object for that event\n   * @param {event} e a mouse/touch event to normalise\n   * @returns {object} normalised event client object (x,y)\n   **/\n  function normalisedClient(e) {\n    if (e.type.includes(\"touch\")) {\n      return e.touches[0];\n    } else {\n      return e;\n    }\n  }\n\n  /**\n   * check if an element is a handle on the slider\n   * @param {object} el dom object reference we want to check\n   * @returns {boolean}\n   **/\n  function targetIsHandle(el) {\n    const handles = slider.querySelectorAll(\".handle\");\n    const isHandle = Array.prototype.includes.call(handles, el);\n    const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));\n    return isHandle || isChild;\n  }\n\n  /**\n   * trim the values array based on whether the property\n   * for 'range' is 'min', 'max', or truthy. This is because we\n   * do not want more than one handle for a min/max range, and we do\n   * not want more than two handles for a true range.\n   * @param {array} values the input values for the rangeSlider\n   * @return {array} the range array for creating a rangeSlider\n   **/\n  function trimRange(values) {\n    if (range === \"min\" || range === \"max\") {\n      return values.slice(0, 1);\n    } else if (range) {\n      return values.slice(0, 2);\n    } else {\n      return values;\n    }\n  }\n\n  /**\n   * helper to return the slider dimensions for finding\n   * the closest handle to user interaction\n   * @return {object} the range slider DOM client rect\n   **/\n  function getSliderDimensions() {\n    return slider.getBoundingClientRect();\n  }\n\n  /**\n   * helper to return closest handle to user interaction\n   * @param {object} clientPos the client{x,y} positions to check against\n   * @return {number} the index of the closest handle to clientPos\n   **/\n  function getClosestHandle(clientPos) {\n    // first make sure we have the latest dimensions\n    // of the slider, as it may have changed size\n    const dims = getSliderDimensions();\n    // calculate the interaction position, percent and value\n    let handlePos = 0;\n    let handlePercent = 0;\n    let handleVal = 0;\n    if (vertical) {\n      handlePos = clientPos.clientY - dims.top;\n      handlePercent = (handlePos / dims.height) * 100;\n      handlePercent = reversed ? handlePercent : 100 - handlePercent;\n    } else {\n      handlePos = clientPos.clientX - dims.left;\n      handlePercent = (handlePos / dims.width) * 100;\n      handlePercent = reversed ? 100 - handlePercent : handlePercent;\n    }\n    handleVal = ((max - min) / 100) * handlePercent + min;\n\n    let closest;\n\n    // if we have a range, and the handles are at the same\n    // position, we want a simple check if the interaction\n    // value is greater than return the second handle\n    if (range === true && values[0] === values[1]) {\n      if (handleVal > values[1]) {\n        return 1;\n      } else {\n        return 0;\n      }\n      // if there are multiple handles, and not a range, then\n      // we sort the handles values, and return the first one closest\n      // to the interaction value\n    } else {\n      closest = values.indexOf(\n        [...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]\n      );\n    }\n    return closest;\n  }\n\n  /**\n   * take the interaction position on the slider, convert\n   * it to a value on the range, and then send that value\n   * through to the moveHandle() method to set the active\n   * handle's position\n   * @param {object} clientPos the client{x,y} of the interaction\n   **/\n  function handleInteract(clientPos) {\n    // first make sure we have the latest dimensions\n    // of the slider, as it may have changed size\n    const dims = getSliderDimensions();\n    // calculate the interaction position, percent and value\n    let handlePos = 0;\n    let handlePercent = 0;\n    let handleVal = 0;\n    if (vertical) {\n      handlePos = clientPos.clientY - dims.top;\n      handlePercent = (handlePos / dims.height) * 100;\n      handlePercent = reversed ? handlePercent : 100 - handlePercent;\n    } else {\n      handlePos = clientPos.clientX - dims.left;\n      handlePercent = (handlePos / dims.width) * 100;\n      handlePercent = reversed ? 100 - handlePercent : handlePercent;\n    }\n    handleVal = ((max - min) / 100) * handlePercent + min;\n    // move handle to the value\n    moveHandle(activeHandle, handleVal);\n  }\n\n  /**\n   * move a handle to a specific value, respecting the clamp/align rules\n   * @param {number} index the index of the handle we want to move\n   * @param {number} value the value to move the handle to\n   * @return {number} the value that was moved to (after alignment/clamping)\n   **/\n  function moveHandle(index, value) {\n    // align & clamp the value so we're not doing extra\n    // calculation on an out-of-range value down below\n    value = alignValueToStep(value);\n    // use the active handle if handle index is not provided\n    if ( typeof index === 'undefined' ) {\n      index = activeHandle;\n    }\n    // if this is a range slider perform special checks\n    if (range) {\n      // restrict the handles of a range-slider from\n      // going past one-another unless \"pushy\" is true\n      if (index === 0 && value > values[1]) {\n        if (pushy) {\n          values[1] = value;\n        } else {\n          value = values[1];\n        }\n      } else if (index === 1 && value < values[0]) {\n        if (pushy) {\n          values[0] = value;\n        } else {\n          value = values[0];\n        }\n      }\n    }\n\n    // if the value has changed, update it\n    if (values[index] !== value) {\n      values[index] = value;\n    }\n\n    // fire the change event when the handle moves,\n    // and store the previous value for the next time\n    if (previousValue !== value) {\n      eChange();\n      previousValue = value;\n    }\n    return value;\n  }\n\n  /**\n   * helper to find the beginning range value for use with css style\n   * @param {array} values the input values for the rangeSlider\n   * @return {number} the beginning of the range\n   **/\n  function rangeStart(values) {\n    if (range === \"min\") {\n      return 0;\n    } else {\n      return values[0];\n    }\n  }\n\n  /**\n   * helper to find the ending range value for use with css style\n   * @param {array} values the input values for the rangeSlider\n   * @return {number} the end of the range\n   **/\n  function rangeEnd(values) {\n    if (range === \"max\") {\n      return 0;\n    } else if (range === \"min\") {\n      return 100 - values[0];\n    } else {\n      return 100 - values[1];\n    }\n  }\n\n  /**\n   * when the user has unfocussed (blurred) from the\n   * slider, deactivate all handles\n   * @param {event} e the event from browser\n   **/\n  function sliderBlurHandle(e) {\n    if (keyboardActive) {\n      focus = false;\n      handleActivated = false;\n      handlePressed = false;\n    }\n  }\n\n  /**\n   * when the user focusses the handle of a slider\n   * set it to be active\n   * @param {event} e the event from browser\n   **/\n  function sliderFocusHandle(e) {\n    if ( !disabled ) {\n      activeHandle = index(e.target);\n      focus = true;\n    }\n  }\n\n  /**\n   * handle the keyboard accessible features by checking the\n   * input type, and modfier key then moving handle by appropriate amount\n   * @param {event} e the event from browser\n   **/\n  function sliderKeydown(e) {\n    if ( !disabled ) {\n      const handle = index(e.target);\n      let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;\n      let prevent = false;\n\n      switch (e.key) {\n        case \"PageDown\":\n          jump *= 10;\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n          moveHandle(handle, values[handle] + jump);\n          prevent = true;\n          break;\n        case \"PageUp\":\n          jump *= 10;\n        case \"ArrowLeft\":\n        case \"ArrowDown\":\n          moveHandle(handle, values[handle] - jump);\n          prevent = true;\n          break;\n        case \"Home\":\n          moveHandle(handle, min);\n          prevent = true;\n          break;\n        case \"End\":\n          moveHandle(handle, max);\n          prevent = true;\n          break;\n      }\n      if (prevent) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }\n\n  /**\n   * function to run when the user touches\n   * down on the slider element anywhere\n   * @param {event} e the event from browser\n   **/\n  function sliderInteractStart(e) {\n    if ( !disabled ) {\n      const el = e.target;\n      const clientPos = normalisedClient(e);\n      // set the closest handle as active\n      focus = true;\n      handleActivated = true;\n      handlePressed = true;\n      activeHandle = getClosestHandle(clientPos);\n\n      // fire the start event\n      startValue = previousValue = alignValueToStep(values[activeHandle]);\n      eStart();\n\n      // for touch devices we want the handle to instantly\n      // move to the position touched for more responsive feeling\n      if (e.type === \"touchstart\" && !el.matches(\".pipVal\")) {\n        handleInteract(clientPos);\n      }\n    }\n  }\n\n  /**\n   * function to run when the user stops touching\n   * down on the slider element anywhere\n   * @param {event} e the event from browser\n   **/\n  function sliderInteractEnd(e) {\n    // fire the stop event for touch devices\n    if (e.type === \"touchend\") {\n      eStop();\n    }\n    handlePressed = false;\n  }\n\n  /**\n   * unfocus the slider if the user clicked off of\n   * it, somewhere else on the screen\n   * @param {event} e the event from browser\n   **/\n  function bodyInteractStart(e) {\n    keyboardActive = false;\n    if (focus && e.target !== slider && !slider.contains(e.target)) {\n      focus = false;\n    }\n  }\n\n  /**\n   * send the clientX through to handle the interaction\n   * whenever the user moves acros screen while active\n   * @param {event} e the event from browser\n   **/\n  function bodyInteract(e) {\n    if ( !disabled ) {\n      if (handleActivated) {\n        handleInteract(normalisedClient(e));\n      }\n    }\n  }\n\n  /**\n   * if user triggers mouseup on the body while\n   * a handle is active (without moving) then we\n   * trigger an interact event there\n   * @param {event} e the event from browser\n   **/\n  function bodyMouseUp(e) {\n    if ( !disabled ) {\n      const el = e.target;\n      // this only works if a handle is active, which can\n      // only happen if there was sliderInteractStart triggered\n      // on the slider, already\n      if (handleActivated) {\n        if (el === slider || slider.contains(el)) {\n          focus = true;\n          // don't trigger interact if the target is a handle (no need) or\n          // if the target is a label (we want to move to that value from rangePips)\n          if (!targetIsHandle(el) && !el.matches(\".pipVal\")) {\n            handleInteract(normalisedClient(e));\n          }\n        }\n        // fire the stop event for mouse device\n        // when the body is triggered with an active handle\n        eStop();\n      }\n    }\n    handleActivated = false;\n    handlePressed = false;\n  }\n\n  /**\n   * if user triggers touchend on the body then we\n   * defocus the slider completely\n   * @param {event} e the event from browser\n   **/\n  function bodyTouchEnd(e) {\n    handleActivated = false;\n    handlePressed = false;\n  }\n\n  function bodyKeyDown(e) {\n    if ( !disabled ) {\n      if (e.target === slider || slider.contains(e.target)) {\n        keyboardActive = true;\n      }\n    }\n  }\n\n  function eStart() {\n    !disabled && dispatch(\"start\", {\n      activeHandle,\n      value: startValue,\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n\n  function eStop() {\n    !disabled && dispatch(\"stop\", {\n      activeHandle,\n      startValue: startValue,\n      value: values[activeHandle],\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n\n  function eChange() {\n    !disabled && dispatch(\"change\", {\n      activeHandle,\n      startValue: startValue,\n      previousValue:\n        typeof previousValue === \"undefined\" ? startValue : previousValue,\n      value: values[activeHandle],\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n</script>\n\n<style>\n  :global(.rangeSlider) {\n    --slider: var(--range-slider, #d7dada);\n    --handle-inactive: var(--range-handle-inactive, #99a2a2);\n    --handle: var(--range-handle, #838de7);\n    --handle-focus: var(--range-handle-focus, #4a40d4);\n    --handle-border: var(--range-handle-border, var(--handle));\n    --range-inactive: var(--range-range-inactive, var(--handle-inactive));\n    --range: var(--range-range, var(--handle-focus));\n    --float-inactive: var(--range-float-inactive, var(--handle-inactive));\n    --float: var(--range-float, var(--handle-focus));\n    --float-text: var(--range-float-text, white);\n  }\n  :global(.rangeSlider) {\n    position: relative;\n    border-radius: 100px;\n    height: 0.5em;\n    margin: 1em;\n    transition: opacity 0.2s ease;\n    user-select: none;\n  }\n  :global(.rangeSlider *) {\n    user-select: none;\n  }\n  :global(.rangeSlider.pips) {\n    margin-bottom: 1.8em;\n  }\n  :global(.rangeSlider.pip-labels) {\n    margin-bottom: 2.8em;\n  }\n  :global(.rangeSlider.vertical) {\n    display: inline-block;\n    border-radius: 100px;\n    width: 0.5em;\n    min-height: 200px;\n  }\n  :global(.rangeSlider.vertical.pips) {\n    margin-right: 1.8em;\n    margin-bottom: 1em;\n  }\n  :global(.rangeSlider.vertical.pip-labels) {\n    margin-right: 2.8em;\n    margin-bottom: 1em;\n  }\n  :global(.rangeSlider .rangeHandle) {\n    position: absolute;\n    display: block;\n    height: 1.4em;\n    width: 1.4em;\n    top: 0.25em;\n    bottom: auto;\n    transform: translateY(-50%) translateX(-50%);\n    z-index: 2;\n  }\n  :global(.rangeSlider.reversed .rangeHandle) {\n    transform: translateY(-50%) translateX(50%);\n  }\n  :global(.rangeSlider.vertical .rangeHandle) {\n    left: 0.25em;\n    top: auto;\n    transform: translateY(50%) translateX(-50%);\n  }\n  :global(.rangeSlider.vertical.reversed .rangeHandle) {\n    transform: translateY(-50%) translateX(-50%);\n  }\n  :global(.rangeSlider .rangeNub),\n  :global(.rangeSlider .rangeHandle:before) {\n    position: absolute;\n    left: 0;\n    top: 0;\n    display: block;\n    border-radius: 10em;\n    height: 100%;\n    width: 100%;\n    transition: box-shadow 0.2s ease;\n  }\n  :global(.rangeSlider .rangeHandle:before) {\n    content: \"\";\n    left: 1px;\n    top: 1px;\n    bottom: 1px;\n    right: 1px;\n    height: auto;\n    width: auto;\n    box-shadow: 0 0 0 0px var(--handle-border);\n    opacity: 0;\n  }\n  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle:hover:before) {\n    box-shadow: 0 0 0 8px var(--handle-border);\n    opacity: 0.2;\n  }\n  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle.press:before),\n  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle.press:hover:before) {\n    box-shadow: 0 0 0 12px var(--handle-border);\n    opacity: 0.4;\n  }\n  :global(.rangeSlider.range:not(.min):not(.max) .rangeNub) {\n    border-radius: 10em 10em 10em 1.6em;\n  }\n  :global(.rangeSlider.range .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(-135deg);\n  }\n  :global(.rangeSlider.range .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(45deg);\n  }\n  :global(.rangeSlider.range.reversed .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(45deg);\n  }\n  :global(.rangeSlider.range.reversed .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(-135deg);\n  }\n  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(135deg);\n  }\n  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(-45deg);\n  }\n  :global(.rangeSlider.range.vertical.reversed .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(-45deg);\n  }\n  :global(.rangeSlider.range.vertical.reversed .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(135deg);\n  }\n  :global(.rangeSlider .rangeFloat) {\n    display: block;\n    position: absolute;\n    left: 50%;\n    top: -0.5em;\n    transform: translate(-50%, -100%);\n    font-size: 1em;\n    text-align: center;\n    opacity: 0;\n    pointer-events: none;\n    white-space: nowrap;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n    padding: 0.2em 0.4em;\n    border-radius: 0.2em;\n  }\n  :global(.rangeSlider .rangeHandle.active .rangeFloat),\n  :global(.rangeSlider.hoverable .rangeHandle:hover .rangeFloat) {\n    opacity: 1;\n    top: -0.2em;\n    transform: translate(-50%, -100%);\n  }\n  :global(.rangeSlider .rangeBar) {\n    position: absolute;\n    display: block;\n    transition: background 0.2s ease;\n    border-radius: 1em;\n    height: 0.5em;\n    top: 0;\n    user-select: none;\n    z-index: 1;\n  }\n  :global(.rangeSlider.vertical .rangeBar) {\n    width: 0.5em;\n    height: auto;\n  }\n  :global(.rangeSlider) {\n    background-color: #d7dada;\n    background-color: var(--slider);\n  }\n  :global(.rangeSlider .rangeBar) {\n    background-color: #99a2a2;\n    background-color: var(--range-inactive);\n  }\n  :global(.rangeSlider.focus .rangeBar) {\n    background-color: #838de7;\n    background-color: var(--range);\n  }\n  :global(.rangeSlider .rangeNub) {\n    background-color: #99a2a2;\n    background-color: var(--handle-inactive);\n  }\n  :global(.rangeSlider.focus .rangeNub) {\n    background-color: #838de7;\n    background-color: var(--handle);\n  }\n  :global(.rangeSlider .rangeHandle.active .rangeNub) {\n    background-color: #4a40d4;\n    background-color: var(--handle-focus);\n  }\n  :global(.rangeSlider .rangeFloat) {\n    color: white;\n    color: var(--float-text);\n    background-color: #99a2a2;\n    background-color: var(--float-inactive);\n  }\n  :global(.rangeSlider.focus .rangeFloat) {\n    background-color: #4a40d4;\n    background-color: var(--float);\n  }\n  :global(.rangeSlider.disabled) {\n    opacity: 0.5;\n  }\n  :global(.rangeSlider.disabled .rangeNub) {\n    background-color: #d7dada;\n    background-color: var(--slider);\n  }\n</style>\n\n<div\n  {id}\n  bind:this={slider}\n  class=\"rangeSlider\"\n  class:range\n  class:disabled\n  class:hoverable\n  class:vertical\n  class:reversed\n  class:focus\n  class:min={range === 'min'}\n  class:max={range === 'max'}\n  class:pips\n  class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}\n  on:mousedown={sliderInteractStart}\n  on:mouseup={sliderInteractEnd}\n  on:touchstart|preventDefault={sliderInteractStart}\n  on:touchend|preventDefault={sliderInteractEnd}\n>\n  {#each values as value, index}\n    <span\n      role=\"slider\"\n      class=\"rangeHandle\"\n      class:active={focus && activeHandle === index}\n      class:press={handlePressed && activeHandle === index}\n      data-handle={index}\n      on:blur={sliderBlurHandle}\n      on:focus={sliderFocusHandle}\n      on:keydown={sliderKeydown}\n      style=\"{orientationStart}: {$springPositions[index]}%; z-index: {activeHandle === index ? 3 : 2};\"\n      aria-valuemin={range === true && index === 1 ? values[0] : min}\n      aria-valuemax={range === true && index === 0 ? values[1] : max}\n      aria-valuenow={value}\n      aria-valuetext=\"{prefix}{handleFormatter(value,index,percentOf(value))}{suffix}\"\n      aria-orientation={vertical ? 'vertical' : 'horizontal'}\n      aria-disabled={disabled}\n      {disabled}\n      tabindex=\"{ disabled ? -1 : 0 }\"\n    >\n      <span class=\"rangeNub\" />\n      {#if float}\n        <span class=\"rangeFloat\">\n          {#if prefix}<span class=\"rangeFloat-prefix\">{prefix}</span>{/if}{handleFormatter(value,index,percentOf(value))}{#if suffix}<span class=\"rangeFloat-suffix\">{suffix}</span>{/if}\n        </span>\n      {/if}\n    </span>\n  {/each}\n  {#if range}\n    <span\n      class=\"rangeBar\"\n      style=\"{orientationStart}: {rangeStart($springPositions)}%; \n             {orientationEnd}: {rangeEnd($springPositions)}%;\" />\n  {/if}\n  {#if pips}\n    <RangePips\n      {values}\n      {min}\n      {max}\n      {step}\n      {range}\n      {vertical}\n      {reversed}\n      {orientationStart}\n      {hoverable}\n      {disabled}\n      {all}\n      {first}\n      {last}\n      {rest}\n      {pipstep}\n      {prefix}\n      {suffix}\n      {formatter}\n      {focus}\n      {percentOf}\n      {moveHandle}\n      {fixFloat}\n    />\n  {/if}\n</div>\n\n<svelte:window\n  on:mousedown={bodyInteractStart}\n  on:touchstart={bodyInteractStart}\n  on:mousemove={bodyInteract}\n  on:touchmove={bodyInteract}\n  on:mouseup={bodyMouseUp}\n  on:touchend={bodyTouchEnd}\n  on:keydown={bodyKeyDown} />\n","<script>\r\n\timport { panzoom } from '$lib/panzoom.js';\r\n\timport { pzoom } from '$lib/pzoom';\r\n\timport Spot from '$lib/_components/Spot.svelte';\r\n\timport RangeSlider from 'svelte-range-slider-pips';\r\n\r\n\tlet zoomable, container;\r\n\tlet style = ''; // show styling applied\r\n\tlet scale = { value: 1 };\r\n\tlet count = 10;\r\n\tlet min = count;\r\n\tlet manualZoom = [1];\r\n\t// $: if (scale?.value) manualZoom = [scale.value]; // match the directive scale level\r\n\t$: if (manualZoom) {\r\n\t\tconsole.log({ manualZoom });\r\n\t\tsetZoom(manualZoom);\r\n\t}\r\n\r\n\tfunction handleZoom(e) {\r\n\t\tconsole.log('Zoomed.', { detail: e.detail });\r\n\t\tscale = e.detail.scale;\r\n\t\tstyle = zoomable.style.transform;\r\n\t}\r\n\r\n\tconst grid = Array.from({ length: count }, (_, i) =>\r\n\t\tArray.from({ length: count }, (_, j) => ({ id: i * count + j }))\r\n\t);\r\n\r\n\t// manual zoom\r\n\tfunction setZoom(val) {\r\n\t\tconsole.log('Zoom to ', val, zoomable?.style['transform']);\r\n\t\tif (!zoomable) return;\r\n\t\tif (!zoomable?.style) {\r\n\t\t\tconsole.log('Setting Zoom to scale only');\r\n\t\t\tzoomable.style['transform'] = `scale(${val})`;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet m;\r\n\t\tlet s = '';\r\n\r\n\t\tconst re = /(\\w+)\\(([^)]*)\\)/g;\r\n\t\twhile ((m = re.exec(zoomable?.style['transform']))) {\r\n\t\t\tconsole.log({ m });\r\n\r\n\t\t\tif (m[1] == 'matrix') {\r\n\t\t\t\tlet piece = m[2].split(', ');\r\n\t\t\t\tconsole.log({ piece });\r\n\t\t\t\ts = `translate(${piece[4]}px, ${piece[5]}px) scale(${val})`;\r\n\t\t\t\tconsole.log('matrixed', { s });\r\n\t\t\t\tzoomable.style['transform'] = s;\r\n\t\t\t\treturn;\r\n\t\t\t} else if (m[1] == 'scale') {\r\n\t\t\t\ts += ` scale(${val})`;\r\n\t\t\t} else {\r\n\t\t\t\ts += m[0];\r\n\t\t\t}\r\n\t\t}\r\n\t\tconsole.log({ s });\r\n\t\tzoomable.style['transform'] = s;\r\n\t}\r\n</script>\r\n\r\n<div>\r\n\t<h1>Pan and Zoom</h1>\r\n\t<p>Try out the mouse wheel scroll in the red box below</p>\r\n\r\n\t<h2>Inside</h2>\r\n\t<p>Inside the red box should pan and zoom</p>\r\n</div>\r\n\r\n<div class=\"container\" bind:this={container}>\r\n\t<div class=\"menu\">\r\n\t\t<div>\r\n\t\t\tZoom Level: {scale.value.toFixed(5)} || {JSON.stringify(manualZoom)}\r\n\t\t\t{#if manualZoom}\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<RangeSlider\r\n\t\t\t\t\t\tpips\r\n\t\t\t\t\t\tmin={0.5}\r\n\t\t\t\t\t\tstep={0.5}\r\n\t\t\t\t\t\tmax={scale?.max || 20}\r\n\t\t\t\t\t\tfloat\r\n\t\t\t\t\t\tbind:values={manualZoom}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t{/if}\r\n\t\t</div>\r\n\r\n\t\t<div>Style: {style}</div>\r\n\t</div>\r\n\t<div class=\"zoomable flexbox\" bind:this={zoomable} use:pzoom on:zoomed={handleZoom}>\r\n\t\t{#if container}\r\n\t\t\t<div class=\"grid\">\r\n\t\t\t\t{#each grid as col, x}\r\n\t\t\t\t\t<div class=\"col\">\r\n\t\t\t\t\t\t{#each col as square, y}\r\n\t\t\t\t\t\t\t<Spot\r\n\t\t\t\t\t\t\t\tleft={min + (x * container.offsetWidth) / count}\r\n\t\t\t\t\t\t\t\ttop={min + (y * container.offsetWidth) / count}\r\n\t\t\t\t\t\t\t/>\r\n\t\t\t\t\t\t{/each}\r\n\t\t\t\t\t</div>\r\n\t\t\t\t{/each}\r\n\t\t\t</div>\r\n\t\t{/if}\r\n\t</div>\r\n</div>\r\n\r\n<style>\r\n\t.container {\r\n\t\tborder: 3px solid red;\r\n\t\theight: 600px;\r\n\t\twidth: 600px;\r\n\t\tmargin: 3em;\r\n\t\t/* overflow: hidden;  its set by the directive :) */\r\n\t\t/* touch-action: none;  its set by the directive :) */\r\n\t\t/* position: relative; its set by the directive :) */\r\n\t}\r\n\t.zoomable {\r\n\t\tborder: 4px dashed blue;\r\n\t\theight: 100%;\r\n\t\twidth: 100%;\r\n\t\t/* margin: 1em; */\r\n\t\t/* position: relative; its set by the directive :) */\r\n\t}\r\n\t.flexbox {\r\n\t\tdisplay: flex;\r\n\t\tflex-wrap: nowrap;\r\n\t\talign-content: stretch;\r\n\t\tjustify-content: space-evenly;\r\n\t\talign-items: stretch;\r\n\t}\r\n\t.flexitem {\r\n\t\tmargin: 1em;\r\n\t\tpadding: 1em;\r\n\t\tbackground-color: lightgray;\r\n\t}\r\n\t.item {\r\n\t\t/* \t\tflex: 1; */\r\n\t\tborder: 1px solid grey;\r\n\t\theight: 30px;\r\n\t\twidth: 50px;\r\n\t}\r\n\tul {\r\n\t\tpadding: 1em;\r\n\t}\r\n\r\n\t.menu {\r\n\t\tposition: absolute;\r\n\t\ttop: 10px;\r\n\t\tleft: 10px;\r\n\t\tmargin: 0.1em;\r\n\t\tpadding: 2em;\r\n\t\tz-index: 10;\r\n\t\tbackground-color: rgba(133, 198, 255, 0.801);\r\n\t}\r\n</style>\r\n"],"names":["pinchZoom","create_if_block_1","create_if_block_3","create_if_block_2","create_if_block_4","create_if_block"],"mappings":"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"}